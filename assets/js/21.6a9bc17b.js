(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{467:function(e,a,t){e.exports=t.p+"assets/img/babel.c16be003.jpg"},495:function(e,a,t){"use strict";t.r(a);var r=t(2),n=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"webpack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[e._v("#")]),e._v(" webpack")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://xxpromise.gitee.io/webpack5-docs/",target:"_blank",rel:"noopener noreferrer"}},[e._v("尚硅谷 Web 前端之 Webpack5 教程"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904094281236487",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack知识要点"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"webpack的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack的作用"}},[e._v("#")]),e._v(" webpack的作用")]),e._v(" "),a("p",[a("strong",[e._v("其实有以下几点：")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("模块打包。可以将不同模块的文件打包整合在一起，并且保证它们之间的引用正确，执行有序。利用打包我们就可以在开发的时候根据我们自己的业务自由划分文件模块，保证项目结构的清晰和可读性。")])]),e._v(" "),a("li",[a("p",[e._v("编译兼容。在前端的“上古时期”，手写一堆浏览器兼容代码一直是令前端工程师头皮发麻的事情，而在今天这个问题被大大的弱化了，通过webpack的Loader机制，不仅仅可以帮助我们对代码做polyfill，还可以编译转换诸如.less, .vue, .jsx这类在浏览器无法识别的格式文件，让我们在开发的时候可以使用新特性和新语法做开发，提高开发效率。")])]),e._v(" "),a("li",[a("p",[e._v("能力扩展。通过webpack的Plugin机制，我们在实现模块化打包和编译兼容的基础上，可以进一步实现诸如按需加载，代码压缩等一系列功能，帮助我们进一步提高自动化程度，工程效率以及打包输出的质量。")])])]),e._v(" "),a("h2",{attrs:{id:"webpack-内部执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-内部执行流程"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://champyin.com/2020/01/12/%E6%8F%AD%E7%A7%98webpack-plugin/",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack 内部执行流程"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("一次完整的 webpack 打包大致是这样的过程：")]),e._v(" "),a("ul",[a("li",[e._v("将命令行参数与 webpack 配置文件 合并、解析得到参数对象。")]),e._v(" "),a("li",[e._v("参数对象传给 webpack 执行得到 Compiler 对象。")]),e._v(" "),a("li",[e._v("执行 Compiler 的 run方法开始编译。每次执行 run 编译都会生成一个 Compilation 对象。")]),e._v(" "),a("li",[e._v("触发 Compiler 的 make方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象。")]),e._v(" "),a("li",[e._v("生成入口文件 AST(抽象语法树)，通过 AST 分析和递归加载依赖模块。")]),e._v(" "),a("li",[e._v("所有模块分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装。")]),e._v(" "),a("li",[e._v("最后执行 Compiler 的 emitAssets 方法把生成的文件输出到 output 的目录中。")])]),e._v(" "),a("h2",{attrs:{id:"webpack热更新原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack热更新原理"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6844904008432222215",target:"_blank",rel:"noopener noreferrer"}},[e._v("webpack热更新原理"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/30669007",target:"_blank",rel:"noopener noreferrer"}},[e._v("Webpack HMR 原理解析"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。")]),e._v(" "),a("p",[e._v("HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。")]),e._v(" "),a("p",[e._v("后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。")]),e._v(" "),a("h2",{attrs:{id:"首屏优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首屏优化"}},[e._v("#")]),e._v(" 首屏优化")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/7117515006714839047?searchId=202311052119287CD7F268F6A897608CB3",target:"_blank",rel:"noopener noreferrer"}},[e._v("关于首屏优化，我做了哪些"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"webpack优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack优化"}},[e._v("#")]),e._v(" webpack优化")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6844904093463347208#heading-0",target:"_blank",rel:"noopener noreferrer"}},[e._v("带你深度解锁Webpack系列(优化篇)"),a("OutboundLink")],1)]),e._v(" "),a("h3",{attrs:{id:"webpack-打包速度和体积监测"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#webpack-打包速度和体积监测"}},[e._v("#")]),e._v(" webpack 打包速度和体积监测")]),e._v(" "),a("ol",[a("li",[e._v("speed-measure-webpack-plugin：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。")]),e._v(" "),a("li",[e._v("--reportvue-cli-service build --report 获取打包 bundle 信息")])]),e._v(" "),a("h1",{attrs:{id:"babel7-知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#babel7-知识"}},[e._v("#")]),e._v(" "),a("a",{attrs:{href:"https://juejin.cn/post/6844904008679686152",target:"_blank",rel:"noopener noreferrer"}},[e._v("Babel7 知识"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("babel核心\n"),a("img",{attrs:{src:t(467),alt:""}})]),e._v(" "),a("h1",{attrs:{id:"其他优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他优化"}},[e._v("#")]),e._v(" 其他优化")]),e._v(" "),a("h2",{attrs:{id:"渲染长列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染长列表"}},[e._v("#")]),e._v(" 渲染长列表")]),e._v(" "),a("p",[e._v("非完整渲染的长列表一般有两种方式：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("懒渲染：这个就是常见的无限滚动的，每次只渲染一部分（比如 10 条），等剩余部分滚动到可见区域，就再渲染另一部分。")])]),e._v(" "),a("li",[a("p",[e._v("可视区域渲染：只渲染可见部分，不可见部分不渲染。")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);