(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{484:function(e,v,t){"use strict";t.r(v);var n=t(2),_=Object(n.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"数据绑定"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据绑定"}},[e._v("#")]),e._v(" 数据绑定")]),e._v(" "),v("p",[e._v("1、v-bind：单向数据")]),e._v(" "),v("p",[e._v("2、v-module: 双向数据绑定，v-module:value的简写，因为v-module默认收集的就是value的值；所以v-module一般用在表单类元素上，这些元素都有value属性。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"object-defineproperty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#object-defineproperty"}},[e._v("#")]),e._v(" Object.defineProperty")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('    let person = {\n        name: "joy",\n        sex: "男",\n\n    }\n    let number = 18\n    Object.defineProperty(person, "age", {\n        value: 26,\n        enumerable: true,\n        writable: true,\n        configurable: true, //是否可删\n\n        // 读取person的age的时候，get函数（getter）会被调用，并且返回的就是age\n        get: function(){\n            console.log("读取age属性")\n            return number\n        },\n        // 修改person的age的时候，set函数（setter）会被调用，并收到修改的具体值\n        set(value){\n            console.log("修改age属性", value)\n            number = value\n        }\n    })\n')])])]),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue数据代理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue数据代理"}},[e._v("#")]),e._v(" vue数据代理")]),e._v(" "),v("p",[v("img",{attrs:{src:"2022-05-29-18-00-24.png",alt:""}})]),e._v(" "),v("p",[v("strong",[e._v("vue中的数据代理")]),e._v("：把vm中data的数据放在vm中一份，以便编码方便")]),e._v(" "),v("p",[e._v("1、数据代理：通过vm对象来代理data对象中属性的操作（读和写）")]),e._v(" "),v("p",[e._v("2、好处：方便操作data中的数据")]),e._v(" "),v("p",[e._v("3、基本原理：通过Object.defineProperty（）把data对象上的所有属性添加到vm上。为每一个添加到vm上的属性都设置getter/setter，在getter/setter中操作data中对应的属性。")]),e._v(" "),v("p",[v("strong",[e._v("vm._data通过进行数据被劫持，进行响应式更新视图")])]),e._v(" "),v("p",[v("img",{attrs:{src:"2022-05-29-18-14-44.png",alt:""}})]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue事件处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue事件处理"}},[e._v("#")]),e._v(" vue事件处理")]),e._v(" "),v("p",[e._v('@click($event, "hjy"),$event表示点击事件，\n事件的基本使用:\n1.使用v-on :xxx或@xxx绑定事件，其中xxx是事件名;\n2.事件的回调需要配置在methods对象中，最终会在vm 上;\n3.methods中配置的函数，不要用箭头函数!否则this就不是vm了;\n4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm,或组件实例对象;\n5.@click="demo”和@click="demo($event)”效果一致，但后者可以传参;')]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue事件修饰符"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue事件修饰符"}},[e._v("#")]),e._v(" vue事件修饰符")]),e._v(" "),v("p",[e._v("vue中的事件修饰符:\n1.prevent:阻止默认事件（常用）;\n2.stop:阻止事件冒泡（常用);\n3.once:事件只触发一次（常用）;\n4.capture:使用事件的捕获模式;\n5.self:只有event.target是当前操作的元素是才触发事件;\n6.passive:事件的默认行为立即执行，无需等待事件回调执行完毕;\n"),v("strong",[e._v("修饰符可以连续写，链式")])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"键盘事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#键盘事件"}},[e._v("#")]),e._v(" 键盘事件")]),e._v(" "),v("p",[e._v("1.Vue中常用的按键别名：\n回车 => enter\n删除 => delete (捕获“删除”和“退格”键)\n退出 => esc\n空格 => space\n换行 => tab (特殊，必须配合keydown去使用)\n上 => up\n下 => down\n左 => left\n右 => right")]),e._v(" "),v("p",[e._v("2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）")]),e._v(" "),v("p",[e._v("3.系统修饰键（用法特殊）：ctrl、alt、shift、meta\n(1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n(2).配合keydown使用：正常触发事件。")]),e._v(" "),v("p",[e._v("4.也可以使用keyCode去指定具体的按键（不推荐）")]),e._v(" "),v("p",[e._v("5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名")]),e._v(" "),v("p",[v("strong",[e._v("键盘事件可以连续写，链式")])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"计算属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算属性"}},[e._v("#")]),e._v(" 计算属性")]),e._v(" "),v("p",[v("strong",[e._v("计算属性：")]),e._v("\n1.定义：要用的属性不存在，要通过已有属性计算得来。\n2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n3.get函数什么时候执行？\n(1).初次读取时会执行一次。\n(2).当依赖的数据发生改变时会被再次调用。\n4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n5.备注：\n1.计算属性最终会出现在vm上，直接读取使用即可。\n2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"监视属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#监视属性"}},[e._v("#")]),e._v(" 监视属性")]),e._v(" "),v("p",[v("strong",[e._v("监视属性watch：")]),e._v("\n1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n2.监视的属性必须存在，才能进行监视！！\n3.监视的两种写法：\n(1).new Vue时传入watch配置\n(2).通过vm.$watch监视")]),e._v(" "),v("p",[v("strong",[e._v("深度监视：")]),e._v("\n(1).Vue中的watch默认不监测对象内部值的改变（一层）。\n(2).配置deep:true可以监测对象内部值改变（多层）。\n备注：\n(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\n(2).使用watch时根据数据的具体结构，决定是否采用深度监视。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"计算属性与监视属性对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#计算属性与监视属性对比"}},[e._v("#")]),e._v(" 计算属性与监视属性对比")]),e._v(" "),v("p",[e._v("computed和watch之间的区别：\n1.computed能完成的功能，watch都可以完成。\n2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。\n两个重要的小原则：\n1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\n2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，\n这样this的指向才是vm 或 组件实例对象。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"绑定样式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#绑定样式"}},[e._v("#")]),e._v(" 绑定样式")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[e._v('1. class样式\n    写法:class="xxx" xxx可以是字符串、对象、数组。\n            字符串写法适用于：类名不确定，要动态获取。\n            对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n            数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n2. style样式\n        :style="{fontSize: xxx}"其中xxx是动态值。\n        :style="[a,b]"其中a、b是样式对象。\n')])])]),v("hr"),e._v(" "),v("h2",{attrs:{id:"条件渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#条件渲染"}},[e._v("#")]),e._v(" 条件渲染")]),e._v(" "),v("p",[v("strong",[e._v("1.v-if")]),e._v('\n写法：\n(1).v-if="表达式"\n(2).v-else-if="表达式"\n(3).v-else="表达式"\n适用于：切换频率较低的场景。\n特点：不展示的DOM元素直接被移除。\n注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。')]),e._v(" "),v("p",[v("strong",[e._v("2.v-show")]),e._v('\n写法：v-show="表达式"\n适用于：切换频率较高的场景。\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉')]),e._v(" "),v("p",[e._v("3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"列表渲染"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#列表渲染"}},[e._v("#")]),e._v(" 列表渲染")]),e._v(" "),v("p",[e._v('v-for指令:\n1.用于展示列表数据\n2.语法：v-for="(item, index) in xxx" :key="yyy"\n3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）')]),e._v(" "),v("p",[v("strong",[e._v("key作用与原理")])]),e._v(" "),v("p",[e._v("面试题：react、vue中的key有什么作用？（key的内部原理）")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("虚拟DOM中key的作用：\nkey是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】,\n随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：")])]),e._v(" "),v("li",[v("p",[e._v("对比规则：\n(1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：\n①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\n②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n(2). 旧虚拟DOM中未找到与新虚拟DOM相同的key\n创建新的真实DOM，随后渲染到到页面。")])]),e._v(" "),v("li",[v("p",[e._v("用index作为key可能会引发的问题：")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("若对数据进行：逆序添加、逆序删除等破坏顺序操作:\n会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。")])]),e._v(" "),v("li",[v("p",[e._v("如果结构中还包含输入类的DOM：\n会产生错误DOM更新 ==> 界面有问题。")])])])]),e._v(" "),v("li",[v("p",[e._v("开发中如何选择key?:")]),e._v(" "),v("ol",[v("li",[e._v("最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。")]),e._v(" "),v("li",[e._v("如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，\n使用index作为key是没有问题的。")])])])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue监测数据改变的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue监测数据改变的原理"}},[e._v("#")]),e._v(" vue监测数据改变的原理")]),e._v(" "),v("p",[v("strong",[e._v("1、模拟对象数据检测")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('    let data = {\n        name: "joy",\n        age: 12\n    }\n    let vm = {}\n    let obs = new Observer(data)\n    vm._data = data = obs\n\n    function Observer(obj){\n        let keys = Object.keys(obj)\n        keys.forEach((key) => {\n            Object.defineProperty(this, key, {\n                get() {\n                    return obj[key]\n                },\n                set(val) {\n                    obj[key] = val\n                }\n            })\n        })\n    }\n')])])]),v("p",[v("strong",[e._v("2、Vue.set()")])]),e._v(" "),v("p",[e._v("参数：")]),e._v(" "),v("ul",[v("li",[e._v("{Object | Array} target")]),e._v(" "),v("li",[e._v("{string | number} propertyName/index")]),e._v(" "),v("li",[e._v("{any} value\n返回值：设置的值。")])]),e._v(" "),v("p",[e._v("用法：")]),e._v(" "),v("p",[e._v("向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = 'hi')")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('    Vue.set(vm.student, "age", 12)\n    vm.$set(vm.student, "age", 12)\n')])])]),v("blockquote",[v("p",[e._v("注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。(不能是vm和v._data)")])]),e._v(" "),v("p",[v("strong",[e._v("3、模拟数组数据检测")]),e._v("\nVue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：")]),e._v(" "),v("blockquote",[v("p",[e._v("push()\npop()\nshift()\nunshift()\nsplice()\nsort()\nreverse()\n或 this.$set(this.students,4,'xiaming')")])]),e._v(" "),v("p",[v("strong",[e._v("4、总结Vue检测数据")]),e._v("\nVue监视数据的原理：\n1.vue会监视data中所有层次的数据。\n2. 如何监测对象中的数据？\n通过setter实现监视，且要在new Vue时就传入要监测的数据。\n(1).对象中后追加的属性，Vue默认不做响应式处理\n(2).如需给后添加的属性做响应式，请使用如下API：\nVue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value)\n3. 如何监测数组中的数据？\n通过包裹数组更新元素的方法实现，本质就是做了两件事：\n(1).调用原生对应的方法对数组进行更新。\n(2).重新解析模板，进而更新页面。\n4.在Vue修改数组中的某个元素一定要用如下方法：\n1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、revere()\n2.Vue.set() 或 vm.$set()\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！")]),e._v(" "),v("hr"),e._v(" "),v("p",[v("strong",[e._v("收集表单数据")]),e._v("\n收集表单数据：")]),e._v(" "),v("ul",[v("li",[e._v("若："),v("code",[e._v('<input type="text"/>')]),e._v("，则v-model收集的是value值，用户输入的就是value值。")]),e._v(" "),v("li",[e._v("若："),v("code",[e._v('<input type="radio"/>')]),e._v("，则v-model收集的是value值，且要给标签配置value值。")]),e._v(" "),v("li",[e._v("若："),v("code",[e._v('<input type="checkbox"/>')]),e._v("\n1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n2.配置input的value属性:\n(1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n(2)v-model的初始值是数组，那么收集的的就是value组成的数组\n"),v("strong",[e._v("备注")]),e._v("：v-model的三个修饰符：\nlazy：失去焦点再收集数据\nnumber：输入字符串转为有效的数字\ntrim：输入首尾空格过滤")])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"过滤器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过滤器"}},[e._v("#")]),e._v(" 过滤器")]),e._v(" "),v("p",[e._v("定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n语法：\n1.注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}\n2.使用过滤器："+e._s(e._f("过滤器名")(e.xxx))+'  或  v-bind:属性 = "xxx | 过滤器名"\n'),v("strong",[e._v("备注：")]),e._v("\n1.过滤器也可以接收额外参数、多个过滤器也可以串联\n2.并没有改变原本的数据, 是产生新的对应的数据")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"内置指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内置指令"}},[e._v("#")]),e._v(" 内置指令")]),e._v(" "),v("ul",[v("li",[e._v("v-bind\t: 单向绑定解析表达式, 可简写为 :xxx")]),e._v(" "),v("li",[e._v("v-model\t: 双向数据绑定")]),e._v(" "),v("li",[e._v("v-for  \t: 遍历数组/对象/字符串")]),e._v(" "),v("li",[e._v("v-on   \t: 绑定事件监听, 可简写为@")]),e._v(" "),v("li",[e._v("v-if \t \t: 条件渲染（动态控制节点是否存存在）")]),e._v(" "),v("li",[e._v("v-else \t: 条件渲染（动态控制节点是否存存在）")]),e._v(" "),v("li",[e._v("v-show \t: 条件渲染 (动态控制节点是否展示)")]),e._v(" "),v("li",[e._v("v-text: 向其所在的节点中渲染文本内容;v-text会替换掉节点中的内容，"+e._s(e.xx)+"则不会。")]),e._v(" "),v("li",[e._v("v-html: 向指定节点中渲染包含html结构的内容。\n"),v("ul",[v("li",[e._v("严重注意：v-html有安全性问题！！！！\n(1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\n(2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！")])])]),e._v(" "),v("li",[e._v("v-cloak指令（没有值）：\n"),v("ol",[v("li",[e._v("本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。")]),e._v(" "),v("li",[e._v("使用css([]属性选择器)配合v-cloak可以解决网速慢时页面展示出"+e._s(e.xxx)+"的问题。")])])]),e._v(" "),v("li",[e._v("v-once指令：\n"),v("ol",[v("li",[e._v("v-once所在节点在初次动态渲染后，就视为静态内容了。")]),e._v(" "),v("li",[e._v("以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。")])])]),e._v(" "),v("li",[e._v("v-pre指令：\n"),v("ol",[v("li",[e._v("跳过其所在节点的编译过程。")]),e._v(" "),v("li",[e._v("可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。")])])])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"自定义指令"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[e._v("#")]),e._v(" 自定义指令")]),e._v(" "),v("p",[v("strong",[e._v("自定义指令何时调用")])]),e._v(" "),v("ol",[v("li",[e._v("指令与元素成功绑定时（一上来）。")]),e._v(" "),v("li",[e._v("指令所在的模板被重新解析时。")])]),e._v(" "),v("p",[v("strong",[e._v("总结")]),e._v("\n注意指令内部的this是window")]),e._v(" "),v("p",[e._v("一、定义语法：\n(1).局部指令：")]),e._v(" "),v("p",[e._v("(2).全局指令：\nVue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)")]),e._v(" "),v("p",[e._v("二、配置对象中常用的3个回调：\n(1).bind：指令与元素成功绑定时调用。\n(2).inserted：指令所在元素被插入页面时调用。\n(3).update：指令所在模板结构被重新解析时调用。")]),e._v(" "),v("p",[e._v("三、备注：\n1.指令定义时不加v-，但使用时要加v-；\n2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。")]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[e._v("#")]),e._v(" Vue生命周期")]),e._v(" "),v("p",[v("img",{attrs:{src:"2022-05-31-15-18-02.png",alt:""}})]),e._v(" "),v("p",[e._v("常用的生命周期钩子：")]),e._v(" "),v("ol",[v("li",[e._v("mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。")]),e._v(" "),v("li",[e._v("beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。")])]),e._v(" "),v("p",[e._v("关于销毁Vue实例")]),e._v(" "),v("ol",[v("li",[e._v("销毁后借助Vue开发者工具看不到任何信息。")]),e._v(" "),v("li",[e._v("销毁后自定义事件会失效，但原生DOM事件依然有效。")]),e._v(" "),v("li",[e._v("一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。")])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"非单文件组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非单文件组件"}},[e._v("#")]),e._v(" 非单文件组件")]),e._v(" "),v("p",[v("strong",[e._v("Vue中使用组件的三大步骤：")])]),e._v(" "),v("p",[e._v("一、 如何定义一个组件？")]),e._v(" "),v("ul",[v("li",[e._v("使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；")]),e._v(" "),v("li",[e._v("区别如下：\n"),v("ol",[v("li",[e._v("el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。")]),e._v(" "),v("li",[e._v("data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。\n备注：使用template可以配置组件结构。")])])])]),e._v(" "),v("p",[e._v("二、如何注册组件？")]),e._v(" "),v("ol",[v("li",[e._v("局部注册：靠new Vue的时候传入components选项")]),e._v(" "),v("li",[e._v("全局注册：靠Vue.component('组件名',组件)")])]),e._v(" "),v("p",[e._v("三、编写组件标签：")]),e._v(" "),v("p",[v("strong",[e._v("注意点：")])]),e._v(" "),v("ol",[v("li",[v("p",[e._v("关于组件名:")]),e._v(" "),v("ul",[v("li",[e._v("一个单词组成：\n"),v("ul",[v("li",[e._v("第一种写法(首字母小写)：school")]),e._v(" "),v("li",[e._v("第二种写法(首字母大写)：School")])])]),e._v(" "),v("li",[e._v("多个单词组成：\n"),v("ul",[v("li",[e._v("第一种写法(kebab-case命名)：my-school")]),e._v(" "),v("li",[e._v("第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持)\n备注：\n(1).组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。\n(2).可以使用name配置项指定组件在开发者工具中呈现的名字。")])])])])]),e._v(" "),v("li",[v("p",[e._v("关于组件标签:\n第一种写法："),v("code",[e._v("<school></school>")]),e._v("\n第二种写法："),v("code",[e._v("<school/>")]),e._v("\n备注：不用使用脚手架时，"),v("code",[e._v("<school/>")]),e._v("会导致后续组件不能渲染。")])]),e._v(" "),v("li",[v("p",[e._v("一个简写方式：")]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("    const school = Vue.extend(options) \n    可简写为：const school = options\n")])])])])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vuecomponent"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuecomponent"}},[e._v("#")]),e._v(" VueComponent")]),e._v(" "),v("p",[v("strong",[e._v("关于VueComponent：")])]),e._v(" "),v("ol",[v("li",[e._v("school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。")]),e._v(" "),v("li",[e._v("我们只需要写"),v("code",[e._v("<school/>或<school></school>")]),e._v("，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。")]),e._v(" "),v("li",[e._v("特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！")]),e._v(" "),v("li",[e._v("关于this指向：\n"),v("ul",[v("li",[e._v("组件配置中：\ndata函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。")]),e._v(" "),v("li",[e._v("new Vue(options)配置中：\ndata函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。")])])]),e._v(" "),v("li",[e._v("VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。Vue的实例对象，以后简称vm。")])]),e._v(" "),v("p",[v("strong",[e._v("一个重要的内置关系")])]),e._v(" "),v("ol",[v("li",[e._v("一个重要的内置关系：")])]),e._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v("VueComponent.prototype.__proto__ === Vue.prototype\n\n\\\\ school.prototype instanceof Vue  ----true\n")])])]),v("ol",{attrs:{start:"2"}},[v("li",[e._v("为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。\n"),v("img",{attrs:{src:"2022-05-31-17-41-06.png",alt:""}})])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"单文件组件-single-file-components"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单文件组件-single-file-components"}},[e._v("#")]),e._v(" 单文件组件( single-file components )")]),e._v(" "),v("p",[e._v(".vue")]),e._v(" "),v("h2",{attrs:{id:"render函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#render函数"}},[e._v("#")]),e._v(" render函数")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("vue.js与vue.runtime.xxx.js的区别：\n(1). vue.js是完整版的Vue，包含：核心功能+模板解析器。\n(2). vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。")])]),e._v(" "),v("li",[v("p",[e._v("因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用\nrender函数接收到的createElement函数去指定具体内容。")])])]),e._v(" "),v("hr"),e._v(" "),v("h2",{attrs:{id:"vue组件传值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue组件传值"}},[e._v("#")]),e._v(" vue组件传值")]),e._v(" "),v("ol",[v("li",[e._v("父子组件通信")])]),e._v(" "),v("ul",[v("li",[e._v("父向子传递数据是通过props，子向父是通过"),v("code",[e._v("$emit")]),e._v("触发事件")]),e._v(" "),v("li",[e._v("通过父链/子链也可以通信（"),v("code",[e._v("$parent/$children）")])]),e._v(" "),v("li",[v("code",[e._v("ref")]),e._v("也可以访问组件实例；")]),e._v(" "),v("li",[v("code",[e._v("provide/inject；$attrs/$listeners")]),e._v("。")])]),e._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://blog.csdn.net/Dax1_/article/details/122825387",target:"_blank",rel:"noopener noreferrer"}},[e._v("浅析provide/inject用法、响应式、全局传递"),v("OutboundLink")],1)])]),e._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[e._v("兄弟组件通信：")])]),e._v(" "),v("ul",[v("li",[e._v("全局事件总线EventBus")])]),e._v(" "),v("blockquote",[v("p",[v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/72777951/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vue事件总线（EventBus）使用详细介绍"),v("OutboundLink")],1)])]),e._v(" "),v("ul",[v("li",[e._v("Vuex。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);