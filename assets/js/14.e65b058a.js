(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{437:function(e,t,s){e.exports=s.p+"assets/img/cc3ad99a10dce2a930024b2af73a9ae2.e0284944.png"},438:function(e,t,s){e.exports=s.p+"assets/img/78e439c6adbc9a3e6db332fe8fc52cda.31bc32f8.png"},439:function(e,t,s){e.exports=s.p+"assets/img/nodetaskqueue.254fcbc4.jpg"},485:function(e,t,s){"use strict";s.r(t);var n=s(2),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs"}},[e._v("#")]),e._v(" nodejs")]),e._v(" "),t("h2",{attrs:{id:"nodejs-的事件循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nodejs-的事件循环"}},[e._v("#")]),e._v(" nodejs 的事件循环")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1870700",target:"_blank",rel:"noopener noreferrer"}},[e._v("一张图带你搞懂 Node 事件循环"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("img",{attrs:{src:s(437),alt:""}})]),e._v(" "),t("p",[t("img",{attrs:{src:s(438),alt:""}})]),e._v(" "),t("p",[e._v("（1）Timers（计时器阶段）：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。")]),e._v(" "),t("p",[e._v("（2）Pending callbacks：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。")]),e._v(" "),t("p",[e._v("（3）Idle/Prepare：仅供内部使用。")]),e._v(" "),t("p",[e._v("（4）Poll（轮询阶段）：")]),e._v(" "),t("ul",[t("li",[e._v("当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。")]),e._v(" "),t("li",[e._v("当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。")])]),e._v(" "),t("p",[e._v("（5）Check（查询阶段）：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。")]),e._v(" "),t("p",[e._v("（6）Close callbacks：执行一些关闭回调，比如socket.on('close', ...)等。")]),e._v(" "),t("p",[e._v("上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask：")]),e._v(" "),t("p",[t("img",{attrs:{src:s(439),alt:""}})]),e._v(" "),t("h2",{attrs:{id:"js-消息队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js-消息队列"}},[e._v("#")]),e._v(" js 消息队列")]),e._v(" "),t("ol",[t("li",[e._v("在执行栈中执行一个宏任务。")]),e._v(" "),t("li",[e._v("在执行过程中遇到微任务和宏任务，分别添加到微任务队列和宏任务队列中去。")]),e._v(" "),t("li",[e._v("当前宏任务执行完毕，立即执行微任务队列中的任务（微任务存在优先级，优先级高的先执行）。")]),e._v(" "),t("li",[e._v("当前微任务队列中的任务执行完毕，检查渲染，GUI 线程接管渲染。")]),e._v(" "),t("li",[e._v("继续执行下一个宏任务从事件队列中取。")])]),e._v(" "),t("blockquote",[t("p",[e._v("同步任务 > 微任务(Vue.nextTick (此时 DOM 所有更改已经完成，数据上已经是最新的 DOM，只是还没有进项页面渲染)) > requestAnimationFrame > DOM 渲染 > 宏任务")])]),e._v(" "),t("h2",{attrs:{id:"node-常用內置模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node-常用內置模块"}},[e._v("#")]),e._v(" node 常用內置模块")]),e._v(" "),t("h3",{attrs:{id:"fs-文件系统模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fs-文件系统模块"}},[e._v("#")]),e._v(" fs 文件系统模块")]),e._v(" "),t("ol",[t("li",[e._v("fs.readFile(path[, option], callback)")]),e._v(" "),t("li",[e._v("fs.writeFile(path,data[,option], callback)")]),e._v(" "),t("li",[e._v("__dirname 表示当前文件所处的目录")])]),e._v(" "),t("h3",{attrs:{id:"path-路径模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#path-路径模块"}},[e._v("#")]),e._v(" path 路径模块")]),e._v(" "),t("ol",[t("li",[e._v("path.join(...paths) 把多个路径片段拼接为完整的路径字符串，凡是涉及路径拼接的操作，都要使用 path.join()方法，使用+拼接库会有./符号导致报错。")]),e._v(" "),t("li",[e._v("path.basename(path[,ext])获取路径中的最后一部分，经常用来获取路径中的文件名。")]),e._v(" "),t("li",[e._v("path.extname(path) 获取路径中的扩展名。")])]),e._v(" "),t("h3",{attrs:{id:"http-模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-模块"}},[e._v("#")]),e._v(" http 模块")]),e._v(" "),t("p",[e._v("通过 http 模块提供的 http.creatServer()方法，为外部提供 web 资源服务。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const http = require('http')\nconst server = http.createServer()\n\nserver.on('request',(req,res)=>{\n  ...\n  res.setHeader('Content-Type', 'text/plain; charset=utf-8')\n  res.end(\"Hello\")\n})\n\nserver.listen(8080,()=>{})\n")])])]),t("h3",{attrs:{id:"net-模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#net-模块"}},[e._v("#")]),e._v(" net 模块")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/67606418",target:"_blank",rel:"noopener noreferrer"}},[e._v("net 模块与通讯的实现"),t("OutboundLink")],1),e._v("\nnet 模块中有两大主要抽象概念——net.Server 和 net.Socket：")]),e._v(" "),t("p",[e._v("Socket 是对 TCP/IP 协议族的一种封装，是应用层与 TCP/IP 协议族通信的中间软件抽象层。它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。")]),e._v(" "),t("p",[e._v("Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip 地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。")]),e._v(" "),t("p",[e._v("简单地说，net.Server 实例可以监听一个端口（用于实现客户端 TCP 连接通讯）或者地址（用于实现 IPC 跨进程通讯），net.Socket 实例可以建立一个套接字实例，它可以用来和 server 建立连接，连接建立后，就可以实现通讯了。你可以将 socket 想象成手机，把 server 想象成基站，虽然不是很贴切，但可以降低理解难度。")]),e._v(" "),t("ol",[t("li",[e._v("server 的建立\n服务器是 net.Server 类的实例，通过 net.createServer([options][,onConnection] )方法建立，如果传入一个函数，则这个函数会作为 connection 事件的回调函数，当一个 socket 实例连接到 server 时，connection 事件就会触发，回调函数中的形参就指向了发起连接的 socket 实例。server 实例并不能独立工作，作为网络服务器使用时需要需要调用 listen 方法来监听一个地址，示例如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const net = require('net');\nconst { StringDecoder } = require('string_decoder');\nlet decoder = new StringDecoder('utf8');\n\nlet server = net.createServer(socket=>{\n   console.log('接收连接');\n   socket.on('data',data=>{\n       console.log('收到来自客户端的消息:',decoder.write(data));\n   });\n\n   socket.on('end',function(){\n      console.log('socket从客户端被关闭了');\n   });\n});\n\nserver.listen(12315);\n\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("Socket 的建立\nSocket 是对 TCP/IP 协议族的一种封装。客户端通讯套接字是 net.Socket 的实例，通过调用实例方法 socket.connect(args)来和服务器建立连接，作为客户端通讯套接字时需要监听端口号，建立连接后，客户端 server 通过 connection 事件的回调函数就可以拿到发起连接的 socket 实例，这样客户端和服务器就可以通讯了，其中一方通过 socket.write（）方法写入数据，另一方注册的监听器 socket.on('data',onData)回调函数就会收到信息。socket 实例化示例如下:")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const net = require('net');\n\nlet socket = new net.Socket();\nsocket.connect(12315);\n//连接服务器\nsocket.on('connect',c=>{\n   console.log('成功建立和12315的连接')\n   setTimeout(()=>{\n       console.log('建立连接1s后发送消息');\n       socket.write('SN:1231512315','utf8',function(){\n           console.log('消息已发送');\n       });\n   },1000);\n});\n\nsocket.on('data',function(resp){\n   console.log('收到服务器返回消息：',resp);\n});\n\nsocket.on('end',function(){\n   console.log('socket从客户端被关闭了');\n})\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[e._v("IPC 通讯\nIPC 通讯是指 Inter Process Communication，也就是跨进程通讯，上一节在提到 cluster 时已经介绍过进程之间是资源隔离的，所以跨进程通讯也需要通过 net 模块来建立消息管道。它的用法比较简单，只需要将 server.listen( )和 socket.connect( )的参数从端口号换成地址字符串就可以了。示例代码如下：")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const net = require('net');\nconst cluster = require('cluster');\nconst path = require('path');\nconst { StringDecoder } = require('string_decoder');\n\nlet serverForIPC;//作为子进程的server\n\nif (cluster.isMaster) {\n   //主进程执行逻辑\n   setupMaster();\n   cluster.fork();//生成子进程\n   cluster.fork();//生成另一个子进程\n} else {\n   //子进程执行逻辑\n   setupWorker();\n}\n\n//主进程逻辑\nfunction setupMaster() {\n   //作为Server监听子进程消息\n  let decoder = new StringDecoder('utf8');\n   //windows系统中要求的IPC通讯命名规则\n  let ipcPath = path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'dashipc');\n  serverForIPC = net.createServer(socket=>{\n       console.log(`[master]:子进程通过ipcServer连接到主进程`);\n       socket.on('data',data=>{\n           console.log('[master]:收到来自子进程的消息:',decoder.write(data));\n       });\n  });\n  //IPC-server端监听指定地址\n  serverForIPC.listen(ipcPath);\n}\n\n//子进程逻辑\nfunction setupWorker() {\n   let ipcPath = path.join('\\\\\\\\?\\\\pipe', process.cwd(), 'dashipc');\n   let socket = new net.Socket();\n   //子进程的socket连接主进程中监听的地址\n   socket.connect(ipcPath,c=>{\n       console.log(`[child-${process.pid}]:pid为${process.pid}的子进程已经连接到主进程`);\n       //过一秒后发个消息测试一下\n       setTimeout(()=>{\n          socket.write(`${process.pid}的消息:SN1231512315`,'utf8',function(){\n             console.log(`[child-${process.pid}]:消息已发送`);\n          });\n       },1000);\n   });\n}\n")])])]),t("h2",{attrs:{id:"express-模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#express-模块"}},[e._v("#")]),e._v(" express 模块")]),e._v(" "),t("h3",{attrs:{id:"基本使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本使用"}},[e._v("#")]),e._v(" 基本使用")]),e._v(" "),t("ol",[t("li",[e._v("创建 web 服务器")]),e._v(" "),t("li",[e._v("处理请求")]),e._v(" "),t("li",[e._v("托管静态资源\n使用 express.static()可以创建一个静态服务器")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const express = require('express')\nconst app = express()\n// 在这里，调用 express.static() 方法，快速的对外提供静态资源\napp.use('/files', express.static('./files'))\napp.use(express.static('./clock'))\napp.listen(80, () => {\n  console.log('express server running at http://127.0.0.1')\n})\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[e._v("使用 nodemon 工具，它能够监听项目文件的变动，当代码被修改后，nodemon 会自动重启项目，极大方便了开发和调试。")])]),e._v(" "),t("h3",{attrs:{id:"express-路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#express-路由"}},[e._v("#")]),e._v(" Express 路由")]),e._v(" "),t("ol",[t("li",[e._v("把路由挂载到app上")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const express = require('express')\nconst app = express()\n// 挂载路由\napp.get('/', (req, res) => {res.send('hello world.')})\napp.post('/', (req, res) => {res.send('Post Request.')})\napp.listen(80, () => {console.log('express server running at http://127.0.0.1')})\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("模块化路由：为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。将路由抽离为单独模块的步骤如下：")])]),e._v(" "),t("ul",[t("li",[e._v("创建路由模块对应的 .js 文件")]),e._v(" "),t("li",[e._v("调用 express.Router() 函数创建路由对象")]),e._v(" "),t("li",[e._v("向路由对象上挂载具体的路由")]),e._v(" "),t("li",[e._v("使用 module.exports 向外共享路由对象")]),e._v(" "),t("li",[e._v("使用 app.use() 函数注册路由模块")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 路由模块 router.js\nconst express = require('express') // 1. 导入 express\nconst router = express.Router() // 2. 创建路由对象\n// 3. 挂载具体的路由\nrouter.get('/user/list', (req, res) => {res.send('Get user list.')})\nrouter.post('/user/add', (req, res) => {res.send('Add new user.')})\n// 4. 向外导出路由对象\nmodule.exports = router\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const express = require('express')\nconst router = require('./router') // 1. 导入路由模块\nconst app = express()\n// 注意： app.use() 函数的作用，就是来注册全局中间件\n// app.use('/files', express.static('./files'))\napp.use('/api', router) // 2. 注册路由模块，跟使用静态资源一样可以加统一的访问前缀\napp.listen(80, () => {console.log('http://127.0.0.1')})\n")])])]),t("h3",{attrs:{id:"express-中间件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#express-中间件"}},[e._v("#")]),e._v(" Express 中间件")]),e._v(" "),t("p",[e._v("当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。多个中间件之间，共享同一份 req和 res。基于这样的特性，我们可以在上游的中间件中，统一为 req 或\nres 对象添加自定义的属性或方法，供下游的中间件或路由进行使用。")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("全局中间件，app.use(中间件函数)")])]),e._v(" "),t("li",[t("p",[e._v("局部中间件")])])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const express = require('express')\nconst app = express()\n// 1. 定义中间件函数\nconst mw1 = (req, res, next) => {\n console.log('调用了局部生效的中间件')\n next()\n}\nconst mw2 = (req, res, next) => {\n console.log('调用了第二个局部生效的中间件')\n next()\n}\n// 2. 创建路由\napp.get('/', mw1, nw2, (req, res) => {res.send('Home page.')})\napp.get('/user', [mw1, mw2],(req, res) => {res.send('User page.')})\napp.listen(80, function () {console.log('Express server running at http://127.0.0.1')})\n\n")])])]),t("p",[t("strong",[e._v("中间件的5个使用注意事项")]),e._v("\n1 一定要在"),t("strong",[e._v("路由之前注册")]),e._v("中间件\n2 客户端发送过来的请求，可以连续调用多个中间件进行处理\n3 执行完中间件的业务代码之后，"),t("strong",[e._v("不要忘记调用 next() 函数")]),e._v("\n4 为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码\n5 连续调用多个中间件时，多个中间件之间，共享req 和 res 对象")])])}),[],!1,null,null,null);t.default=r.exports}}]);