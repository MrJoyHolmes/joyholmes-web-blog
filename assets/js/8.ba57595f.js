(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{443:function(e,t,n){e.exports=n.p+"assets/img/2023-04-01-21-13-01.a6857c71.png"},444:function(e,t,n){e.exports=n.p+"assets/img/2023-04-01-21-14-15.07c67cd8.png"},445:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-17-33-08.d2bdfd52.png"},446:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-17-35-37.72789ff3.png"},447:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-18-40-10.d2bed0e4.png"},448:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-18-40-34.d6f5b263.png"},449:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-18-53-22.7860ae38.png"},450:function(e,t,n){e.exports=n.p+"assets/img/1699016674298.a733f513.png"},451:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-20-36-23.5a1d9157.png"},452:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-20-41-38.11f1dc03.png"},453:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-20-57-15.ccd56e76.png"},454:function(e,t,n){e.exports=n.p+"assets/img/https.7afa0810.png"},455:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-22-26-04.38c6ed5d.png"},456:function(e,t,n){e.exports=n.p+"assets/img/2023-04-02-22-27-10.6ac8e696.png"},488:function(e,t,n){"use strict";n.r(t);var s=n(2),r=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"前端网络知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端网络知识"}},[e._v("#")]),e._v(" 前端网络知识")]),e._v(" "),t("p",[t("strong",[e._v("学习资料：")]),e._v(" "),t("a",{attrs:{href:"https://github.com/lefex/FE",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/lefex/FE"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://juejin.cn/post/6844904045572800525",target:"_blank",rel:"noopener noreferrer"}},[e._v("看完这篇 HTTP，跟面试官扯皮就没问题了"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("介绍前端需要掌握的一些基本网络知识")]),e._v(" "),t("ol",[t("li",[e._v("认识接口；")]),e._v(" "),t("li",[e._v("使用 Node 实现一个简单的 API，探索 API 的实现；")]),e._v(" "),t("li",[e._v("socket 实现；")]),e._v(" "),t("li",[e._v("HTTP 相关知识介绍；")]),e._v(" "),t("li",[e._v("实现一个 WebServer；")]),e._v(" "),t("li",[e._v("前端中的网络请求；")]),e._v(" "),t("li",[e._v("Web FrameWork Express 实践；")]),e._v(" "),t("li",[e._v("跨域请求；")]),e._v(" "),t("li",[e._v("网络安全；")])]),e._v(" "),t("h2",{attrs:{id:"认识接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#认识接口"}},[e._v("#")]),e._v(" 认识接口")]),e._v(" "),t("p",[e._v("用 express 框架实现一个 HTTP 接口")]),e._v(" "),t("ol",[t("li",[e._v("先新建一个文件夹，名字为 app")]),e._v(" "),t("li",[e._v("在这个目录下创建 app.js 文件；")]),e._v(" "),t("li",[e._v("执行 npm init 初始化 package.json 文件，按照提示一路回车即可；")]),e._v(" "),t("li",[e._v("执行 npm install express, 安装 express 框架；")])]),e._v(" "),t("p",[e._v("在 app.js 文件中加入下面代码：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  // 导入 expres 框架\n  const express = require("express");\n  // 初始化 express\n  const app = express();\n\n  //配置静态资源目录\n  app.use(express.static("./public"));\n\n  // get 方法，匹配 path 为 /api/fe/list\n  app.get("/api/data/list", function (req, res) {\n    console.log("request path:" + req.path);\n    var result = {\n      code: 200,\n      data: {\n        name: "前端网络",\n        des: "网络编程内容 HTTP，TCP，WebServer"\n      }\n    };\n    // 响应以 json 的方式返回给客户端\n    res.json(result);\n  });\n  // 监听 8888 端口\n  app.listen(8888);\n\n  console.log("app start: http://127.0.0.1:8888");\n')])])]),t("p",[e._v("创建一个前端文件请求该接口，此处直接实现一个 Ajax 请求，发送 Ajax 请求的五个步骤：")]),e._v(" "),t("p",[e._v("（1）创建异步对象，即 XMLHttpRequest 对象。")]),e._v(" "),t("p",[e._v("（2）使用 open 方法设置请求参数。"),t("code",[e._v("open(method, url, async)")]),e._v("。参数解释：请求的方法、请求的 url、是否异步。第三个参数如果不写，则默认为 true。")]),e._v(" "),t("p",[e._v("（3）发送请求："),t("code",[e._v("send()")]),e._v("。")]),e._v(" "),t("p",[e._v("（4）注册事件：注册 onreadystatechange 事件，状态改变时就会调用。")]),e._v(" "),t("p",[e._v("如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。")]),e._v(" "),t("p",[e._v("（5）服务端响应，获取返回的数据。\n在 express 的服务目录中创建 public/index.html，在 script 标签中加入以下代码")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    let request = new XMLHttpRequest();\n    request.open("get", "http://127.0.0.1:8888/api/data/list", true);\n    request.onreadystatechange = function(){\n      if(request.readyState == 4 && request.status == 200) {\n        console.log(\'数据返回成功：\' + JSON.stringify(request.responseText));\n      }\n    }\n    request.send();\n')])])]),t("p",[e._v("此时一个完整的 HTTP 请求就已经完成。\nExpress 其实是在 Node 的 HTTP 模块基础上进行一次封装，这一点很像端的网络框架。Express 还有一个重要的特征是其强大的路由系统，它的作用可以通过 request 找到对应的代码文件。")]),e._v(" "),t("h2",{attrs:{id:"认识-http-请求的客户端与服务端"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#认识-http-请求的客户端与服务端"}},[e._v("#")]),e._v(" 认识 http 请求的客户端与服务端")]),e._v(" "),t("p",[e._v("从客户端发出一个请求到 server 端会接收请求，这中间发生了很多事情。")]),e._v(" "),t("ul",[t("li",[e._v("为什么请求需要 ip 地址和端口号呢？")]),e._v(" "),t("li",[e._v("端口号是用来干什么的？")]),e._v(" "),t("li",[e._v("server 端是如何发出响应的？")]),e._v(" "),t("li",[e._v("遇到各种状态码该如何找到问题的原因？")]),e._v(" "),t("li",[e._v("为什么抓包软件可以抓取到 HTTP 请求？")]),e._v(" "),t("li",[e._v("HTTPS 是如何实现的？")]),e._v(" "),t("li",[e._v("HTTP 和 TCP 有什么关系呢？")]),e._v(" "),t("li",[e._v("socket 起到了什么作用？")])]),e._v(" "),t("p",[e._v("这些问题，面试的时候被问到的时候，我会给出一个「连我自己都不知道对错的答案」，因为网上就是这么说的，我没有实际验证过，也没看过 HTTP 是如何实现的，而 Node 对 HTTP 模块的实现无疑是为我们这一阶段的学习提供了很多有价值的资料。")]),e._v(" "),t("p",[e._v("使用 Node 中的 HTTP 模块不仅可以实现一个 HTTP server，而且可以作为客户端发起 HTTP 请求，也就是使用 Node 可以同时实现客户端与 server 端。")]),e._v(" "),t("p",[e._v("分析一下下面的代码（server.js 文件），在 Node 中首先需要引用 HTTP 模块，然后通过 HTTP 来创建一个 server 对象，通过 server 对象便可以监听它的一系列事件，其中最常用的是 request 事件，它接收到客户端请求事件时就会执行，这时 server 端会根据请求对象发出的「指令」来做事情。这里，我们只处理了请求 path 为 /api/fe/list 的 request，其它请求一律都走 404。最后需要通过 listen 方法来制定一个端口号。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    const http = require(\'http\');\n    // 创建一个 HTTP server\n    const server = new http.Server();\n\n    /**\n    * request 事件，当客户端发起请求后会响应这个事件\n    * req：请求对象\n    * res：响应对象\n    * */\n    server.on(\'request\', function(req, res) {\n        let path = req.url;\n        if (path.indexOf(\'/api/data/list\') == 0) {\n            // 处理请求的 path 为 /api/fe/list\n            res.writeHead(200, {\n                "Content-type" : "application/json"\n            });\n            let data = {\n                title: "前端小课",\n                des: "内容由素燕公众号发布"\n            };\n            // 最终数据需要转换成 json 字符串\n            res.write(JSON.stringify(data));\n        } else {\n            // 未实现，直接报 404 错误\n            res.writeHead(404, {\n                "Content-type" : "application/json"\n            });\n            let data = {\n                code: "404",\n                msg: "not found"\n            };\n            res.write(JSON.stringify(data));\n        }\n        res.end();\n    });\n\n    // 监听 8888 端口\n    server.listen(8888, function() {\n        console.log(\'Server run in: http://127.0.0.1:8888\');\n    });\n')])])]),t("p",[e._v("Node 的 HTTP 实现是基于事件的，可以通过 on 方法来监听不同的事件。上面的代码中我们监听了 request 事件，它触发的时机是当客户端发起网络请求后，就会执行这个事件。它会携带请求对象 req 和响应对象 res，req 是用来获取客户端的请求数据，这样 server 可以做出正确的响应。")]),e._v(" "),t("p",[e._v("Node 也可以充当客户端来发起网络请求。下面的代码（client.js）创建一个 HTTP 客户端来发起网络请求，通过 http.request 方法来发起请求，通过 options 来声明请求需要的信息。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("\n  const http = require('http');\n\n  // 构建 request 对象所需要的参数\n  const options = {\n      // 请求地址 ip\n      host: '127.0.0.1',\n      // 端口号\n      port: 8888,\n      // 方法\n      method: 'GET',\n      // 请求的路径\n      path: '/api/fe/list',\n      protocol: 'http:',\n      // 超时时间设置 1秒\n      timeout: 1000\n  }\n\n  const req = http.request(options, function (res) {\n      console.log(`STATUS: ${res.statusCode}`);\n      console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n      res.setEncoding('utf8');\n      // 响应数据\n      res.on('data', (chunk) => {\n          console.log(`BODY: ${chunk}`);\n      });\n      // 响应结束\n      res.on('end', () => {\n          console.log('No more data in response.');\n      });\n  });\n\n  req.on('error', (e) => {\n      console.error(`problem with request: ${e.message}`);\n  });\n\n  req.end();\n")])])]),t("p",[e._v("通过 node client.js 执行一下客户端的代码，下面执行了 2 次请求。在执行请求的时候需要先执行 server.js 来启动服务，然后在执行 client.js：")]),e._v(" "),t("h2",{attrs:{id:"认识-tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#认识-tcp"}},[e._v("#")]),e._v(" 认识 tcp")]),e._v(" "),t("p",[e._v("HTTP 属于应用层协议，处于网络七层模型的最顶端，它比较偏业务，类似与传输方与接收方之间的一个约定。比如，快过节了，王老板准备给远方的亲人送一封密信，密信的内容是 HTTP 扮演的角色，必须约定一种规则双方可以能够理解彼此要表达的意思。信使扮演着「传输层」的作用，也就是我们常用到的 TCP 或者 UDP，它只负责把内容可靠地传递到目的地，具体传输什么内容，它不关心。\n"),t("img",{attrs:{src:n(443),alt:"image"}}),e._v(" "),t("img",{attrs:{src:n(444),alt:"image"}}),e._v("\n传输控制协议（TCP，Transmission Control Protocol）是一种"),t("strong",[e._v("面向连接")]),e._v("的、"),t("strong",[e._v("可靠")]),e._v("的、基于"),t("strong",[e._v("字节流")]),e._v("的传输层通信协议。那么如何保证可靠？这就需要采取一定的措施。基于字节流说明在 TCP 传输过程中都是二进制数据，不同的业务方需要制定不同的协议来满足自己的业务。比如 HTTP 协议为了访问网页，SMTP 协议为了收发邮件，它们最终的通信都是基于传输层协议。解决了电脑与电脑直接数据通信的问题，至于应用层协议可以自定义规则，自己想这么玩就咋么玩。曾经做 IM 的时候就是自己制定了通信协议。")]),e._v(" "),t("p",[e._v("再看一段关于 TCP 的描述：")]),e._v(" "),t("blockquote",[t("p",[e._v("The Transmission Control Protocol (TCP) is intended for use as a highly reliable host-to-host protocol between hosts in packet-switched computer communication networks, and in interconnected systems of such networks.")])]),e._v(" "),t("p",[e._v("通过 Node 提供的 net 模块创建 TCP 连接，HTTP 模块其实底层使用的是 net 模块，说明 HTTP 协议是基于 TCP 协议。通过 Node 来创建一个简单的聊天，分别模拟客户端和 Sever 断。创建一个 Sever 端和两个客户端。Sever 端接收到消息后会给客户端回应消息。")]),e._v(" "),t("p",[e._v("tcp_server.js 文件，通过 node tcp_server.js 来启动 TCP server 端。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let net = require('net');\n  // 创建 TCP 服务\n  let server = new net.Server();\n  // 端口号\n  const port = 8888;\n\n  let Log = function(msg) {\n      console.log(msg);\n  };\n  // 消息\n  let serverMsgs = [\n      '💁♂️客服小燕：你可以先学 HTML 与 CSS。',\n      '💁♂️客服小燕：可以关注素燕这个公众号，我就是和作者学习的，内容非常不错。',\n      '💁♂️客服小燕：不客气，请问还有其它事情吗？',\n      '💁♂️客服小燕：那我结束本服务了，有什么问题随时咨询我。',\n  ];\n  // 顺序发送消息给客户端\n  let sendMsg = function(socket) {\n      if (sendIndex < serverMsgs.length) {\n          Log(serverMsgs[sendIndex]);\n          socket.write(serverMsgs[sendIndex]);\n          sendIndex += 1;\n      }\n      Log(sendIndex);\n      if (sendIndex >= serverMsgs.length) {\n          Log('客服小燕：结束了本次服务！');\n          sendIndex = 0;\n      }\n      // 4006186999\n  };\n\n  let sendIndex = 0;\n\n  // 监听 connection 事件\n  server.on(\"connection\", function (socket) {\n      // 当收到客户断消息会响应这个事件\n      socket.on('data', function(data) {\n          // data 是二进制数据\n          Log(data.toString());\n          setTimeout(() => {\n              sendMsg(socket);\n          }, 800);\n      });\n      // 获取连接的客户端数\n      server.getConnections(function(err,count){\n          Log(\"The client count: \" + count);\n      });\n  });\n\n  // 监听某个端口\n  server.listen(port, function() {\n      let address = server.address();\n      Log(\"Server run on: http://127.0.0.1:\" + address.port);\n  });\n\n")])])]),t("p",[e._v("tcp_client.js 文件，通过 node tcp_client.js 来开启 TCP 客户端。，")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  let net = require('net');\n  // 创建一个 Socket 连接\n  let client = net.Socket();\n\n  let Log = function(msg) {\n      console.log(msg);\n  };\n\n  let msgs = [\n      '素燕：你好，如何才能从 0 开始入门前端学习呢？',\n      '素燕：有什么好的资源推荐吗？',\n      '素燕：那我关注学习一下，谢谢你。',\n      '素燕：暂时没有了。'\n  ];\n\n  // 发消息\n  let sendMsg = function() {\n      if (sendIndex < msgs.length) {\n          Log(msgs[sendIndex]);\n          client.write(msgs[sendIndex]);\n          sendIndex += 1;\n      } else {\n          // 发完消息可以关闭这个连接\n          // client.end();\n      }\n  };\n\n  let sendIndex = 0;\n\n  // 连接 TCP Server 端\n  client.connect('8888', '127.0.0.1', function () {\n      Log('have connected to server');\n      sendMsg();\n  });\n\n  // 收到 Server 端发来的消息\n  client.on('data', function (data) {\n      Log(data.toString());\n      setTimeout(() => {\n          sendMsg();\n      }, 1000);\n  });\n\n")])])]),t("h2",{attrs:{id:"认识-socket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#认识-socket"}},[e._v("#")]),e._v(" 认识 socket")]),e._v(" "),t("p",[e._v("什么是 socket？")]),e._v(" "),t("blockquote",[t("p",[e._v("socket 的作用就和它的中文翻译一样：插座，方便使用各种电器，当然你不用插座直接接零线火线也行……")])]),e._v(" "),t("blockquote",[t("p",[e._v("socket 套接字，用于建立端与端之间的通信连接，server 端和客户端都需要建立 socket，之后才能进行 tcp/ip 通信")])]),e._v(" "),t("blockquote",[t("p",[e._v("socket 是一条线的两个插头，一个插在客户端，一个插在服务端，通过这条线实现两端的直连，达到长连接的效果")])]),e._v(" "),t("blockquote",[t("p",[e._v("进程间通信如同文件的读写，都符合 open—write/read—close 模式。而 socket 就是其中一种通信方式的抽象，可以理解为一种文件描述符，用于不同进程间的通信！在传输层面有基于 TCP 的 socket，自然也有基于 UDP 的 socket，当然还有更简单的基于 http 的 websocket……")])]),e._v(" "),t("blockquote",[t("p",[e._v("套接字，实现跨机器的进程间的通信。")])]),e._v(" "),t("blockquote",[t("p",[e._v("套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将 I/O 插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是 IP 地址与端口的组合。"),t("em",[e._v("-- 百度百科。")])])]),e._v(" "),t("p",[e._v("连接到网络中的计算机非常多，为了满足不同网络中的计算机之间进程的通信，socket 就出现了，它的出现解决了计算机在网络中的通信问题。"),t("strong",[e._v("它以「 ip + 端口」的形式来标记一个进程。如果想访问某台计算机中的某个程序，比如它 ip 是 127.0.0.1，端口为 8888，那么就可以通过 127.0.0.1:8888 这样的方式来访问。")]),e._v("“段山洼的小张家”可以理解为某台计算机中的某个进程，用 socket 来说“段山洼”是 ip 地址，小张家是端口号。")]),e._v(" "),t("p",[e._v("人们在通往各村之间可以选择多种交通工具。张三家没钱，只能买辆自行车来骑，但他比较靠谱，交给他办的事 100%能给你搞定；王五这家伙这几年做生意赚钱了，买了辆奥迪，每天开的挺潇洒，但为人丢三落四，交给他办事很快，但是不放心，说不定让他送个东西半路就丢了。我们称“张三”这条线路就叫 TCP 连接，而“王五”这条路线就叫 UDP 连接。它们的连接方式都是通过 socket 建立的连接，也就是村与村之间的连接靠的是 socket ，具体连接到每户人家靠的是端口号，它是一个连接标准，具体连接的靠不靠谱，关键看“人”靠不靠谱。")]),e._v(" "),t("p",[e._v("socket 可以有多种，比如流式，它使用的是 TCP 协议实现的；数据报格式，它使用的是 UDP 实现的。")]),e._v(" "),t("p",[e._v("socket 通信是双向的，客户端可以给 server 端主动发消息，server 端也可以给客户端主动发消息，这一点不想 HTTP 协议，只能客户端主动发起请求。")]),e._v(" "),t("h2",{attrs:{id:"http-与请求报文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-与请求报文"}},[e._v("#")]),e._v(" http 与请求报文")]),e._v(" "),t("p",[e._v("在 HTTP 协议中，「小卖部」扮演的角色类似于 UA（User Agent），UA 其实就是我们常说的客户端，比如浏览器，app，它的作用就是可以发起一个请求（request）。「生产商」扮演的角色是服务端的角色，它为客户端提供资源（response）。当服务端接收到客户端的请求后，会给出一个响应作为回答。总之，HTTP 协议需要一个客户端与一个服务端。")]),e._v(" "),t("p",[e._v("标准」就是 HTTP 协议，双方约定通信内容要按照统一的格式。这个「格式」就是 HTTP 协议规定的报文格式。王经理想了想，生产厂商有非常多的资源，必须要通过一个规则来标识货物，比如牛奶、饼干、面包这些该如何标识，而且一旦生产厂商不能提供货物需要给小卖部一个明确的答复。由于王经理以前干过程序员，然后它直接借鉴了 HTTP 协议的设计。他画了一个草图：")]),e._v(" "),t("p",[t("img",{attrs:{src:n(445),alt:"image"}})]),e._v(" "),t("p",[e._v("HTTP 在发起请求的时候，它会按照协议的规定组合成一条一条文本内容，通过 TCP 来传送到 server 端。当 server 端开启一个 HTTP 服务后，它便会一直监听客户端的请求。整个请求过程，我画了一张图：\n"),t("img",{attrs:{src:n(446),alt:"image"}})]),e._v(" "),t("p",[e._v("HTTP 请求报文看成一段「有格式」的文本，它描述了「我要干什么，我提供了哪些有用的信息」。这个类似于我们平时打电话，要知道对方的电话号码，以及要沟通的事情。我觉得 request 就是干了一件沟通的事情。\n"),t("img",{attrs:{src:n(447),alt:"image"}}),e._v(" "),t("img",{attrs:{src:n(448),alt:"image"}})]),e._v(" "),t("p",[e._v("请求报文由三部分组成：")]),e._v(" "),t("p",[t("strong",[e._v("请求行（request line）")]),e._v("\n基本语法：Method 空格 Request-URI 空格 HTTP 版本 换行。比如：\nPOST /bauhinia/v1/class/purchase/info HTTP/1.1。HTTP 中常用的方法就是 GET 和 POST，主要的作用是要执行什么事件。")]),e._v(" "),t("p",[t("strong",[e._v("请求头（request header）")]),e._v("\nHTTP 的请求标头分为四种： 通用标头、请求标头、响应标头 和 实体标头")]),e._v(" "),t("p",[t("strong",[e._v("请求体（body）")]),e._v("\nPOST 方法会携带请求体，通过 key=value 的形式把不同的值使用&拼接起来。")]),e._v(" "),t("h2",{attrs:{id:"http-响应报文与状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-响应报文与状态码"}},[e._v("#")]),e._v(" http 响应报文与状态码")]),e._v(" "),t("p",[e._v("请求是 UA（User Agent）的事情，它的目的是告诉服务端，我要哪些资源，你给我以某种方式把资源返回。服务端在返回资源的时候，需要按照 HTTP 协议规定的方式返回。这就使得响应报文也有自己的独有的格式。\n"),t("img",{attrs:{src:n(449),alt:"image"}})]),e._v(" "),t("p",[e._v("响应报文由三部分组成：\n"),t("strong",[e._v("状态行（status line）：")]),e._v(" HTTP 版本 空格 状态码 空格 原因短语")]),e._v(" "),t("ul",[t("li",[e._v("1xx: Informational - Request received, continuing process，表示服务端已经接收到请求正在处理中；")]),e._v(" "),t("li",[e._v("2xx: Success - The action was successfully received, understood, and accepted，表示服务端明白了客户端要干什么，也可以做出正确的响应；")]),e._v(" "),t("li",[e._v("3xx: Redirection - Further action must be taken in order to complete the request，重定向，我处理不了你的请求，我需要把它交给其它小伙伴处理；\n"),t("ul",[t("li",[e._v('"301" : Moved Permanently 永久性重定向')]),e._v(" "),t("li",[e._v('"302": Found 原始为 Moved Temporarily 临时性重定向')]),e._v(" "),t("li",[e._v('"304" : Not Modified 缓存')])])]),e._v(" "),t("li",[e._v("4xx: Client Error - The request contains bad syntax or cannot be fulfilled，客户端错误，服务端理解不了请求对象，要么是地址写错了，要么是不符合规则；\n"),t("ul",[t("li",[e._v('"400" : Bad Request')]),e._v(" "),t("li",[e._v('"401" : Unauthorized')])])]),e._v(" "),t("li",[e._v("5xx: Server Error - The server failed to fulfill an apparently valid request，服务端错误，这个时候你可以找服务端小伙伴说：“你的服务挂了”。\n"),t("ul",[t("li",[e._v('"500" : Internal Server Error')]),e._v(" "),t("li",[e._v('"502" : Bad Gateway')]),e._v(" "),t("li",[e._v('"503" : Service Unavailable')]),e._v(" "),t("li",[e._v('"504" : Gateway Time-out')])])])]),e._v(" "),t("p",[t("strong",[e._v("响应头（response header）")])]),e._v(" "),t("p",[t("strong",[e._v("响应体（body）")])]),e._v(" "),t("h3",{attrs:{id:"http-keep-alive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-keep-alive"}},[e._v("#")]),e._v(" HTTP keep-alive")]),e._v(" "),t("p",[e._v("在 HTTP/1.0 协议中，如果请求头中包含：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Connection: keep-alive\n")])])]),t("p",[e._v("则代表开启 keep-alive，而服务端的返回报文头中，也会包含相同的内容。")]),e._v(" "),t("p",[e._v("在 HTTP/1.1 协议中，默认开启 keep-alive，除非显式地关闭它：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Connection: close\n")])])]),t("p",[t("strong",[e._v("用还是不用，这是个问题")])]),e._v(" "),t("ul",[t("li",[e._v("keep-alive 技术创建的目的，就是能在多次 HTTP 之间重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）")]),e._v(" "),t("li",[e._v("如果客户端在接收完所有的信息之后还没有关闭连接，则服务端相应的资源还在被占用（尽管已经没用了）。如果一个长连接实际上已经处理完毕，但关闭的超时时间未到，则该线程会一直被占用。")])]),e._v(" "),t("p",[e._v("显然，如果客户端和服务端的确需要进行多次通信，则开启 keep-alive 是更好的选择，例如在微服务架构中，通常微服务的使用方和提供方会长期有交流，此时最好开启 keep-alive。")]),e._v(" "),t("h2",{attrs:{id:"http缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[e._v("#")]),e._v(" http缓存")]),e._v(" "),t("p",[t("img",{attrs:{src:n(450),alt:""}})]),e._v(" "),t("p",[e._v("ETag/If-None-Match 的出现主要解决了 Last-Modified/If-Modified-Since 所解决不了的问题：")]),e._v(" "),t("ol",[t("li",[e._v("如果文件的修改频率在秒级以下，Last-Modified/If-Modified-Since 会错误地返回 304")]),e._v(" "),t("li",[e._v("如果文件被修改了，但是内容没有任何变化的时候，Last-Modified/If-Modified-Since 会错误地返回 200 ，上面的例子就说明了这个问题")])]),e._v(" "),t("h2",{attrs:{id:"对-http-、tcp、-ip、socket-协议的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对-http-、tcp、-ip、socket-协议的理解"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzUxODI3MjY2Ng==&mid=2247484732&idx=1&sn=4f209555bfe8df1c3a5d6e31eebc6daa&chksm=f98a26c9cefdafdf218f4e6c69a103ec087ef4833627172f867d9d98f16bff14b0bbefebacc9&scene=27",target:"_blank",rel:"noopener noreferrer"}},[e._v("对 HTTP 、TCP、 IP、socket 协议的理解"),t("OutboundLink")],1)]),e._v(" "),t("ol",[t("li",[e._v("HTTP 协议对应应用层，HTTP 协议是基于 TCP 连接的。")]),e._v(" "),t("li",[e._v("TPC/IP 协议是传输层协议，主要解决数据如何在网络中传输。“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把 IP 想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP 和 UDP 是高速公路上的“卡车”，它们携带的货物就是像 HTTP，文件传输协议 FTP 这样的协议等。")]),e._v(" "),t("li",[e._v("套接字(socket)是通信的基石，Socket 是一个针对 TCP 和 UDP 编程的接口，你可以借助它建立 TCP 连接等等。而 TCP 和 UDP 协议属于传输层.")])]),e._v(" "),t("p",[e._v("传输层的 TCP 是基于网络层的 IP 协议的，而应用层的 HTTP 协议又是基于传输层的 TCP 协议的，而 Socket 本身不算是协议，就像上面所说，它只是提供了一个针对 TCP 或者 UDP 编程的接口。socket 是对端口通信开发的工具,它要更底层一些。")]),e._v(" "),t("h2",{attrs:{id:"从-http-到-https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从-http-到-https"}},[e._v("#")]),e._v(" 从 HTTP 到 HTTPS")]),e._v(" "),t("p",[e._v("参考： "),t("a",{attrs:{href:"https://mp.weixin.qq.com/s/MfvUuitrF8MN16nxyZNB8A",target:"_blank",rel:"noopener noreferrer"}},[e._v("用故事说透 HTTPS（漫画）"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43789231",target:"_blank",rel:"noopener noreferrer"}},[e._v("彻底搞懂HTTPS的加密原理"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("HTTP 报文内容是明文传输，很不安全，容易被窃听、篡改，HTTPS 的出现是为了解决这个问题。")]),e._v(" "),t("ol",[t("li",[e._v("内容未加密，容易被监听，都是明文传输；")]),e._v(" "),t("li",[e._v("无法验证内容的完整性，容易被篡改，也就是说不知道消息是不是被修改过；")]),e._v(" "),t("li",[e._v("无法验证对方的身份，我现在聊天的人是谁，可靠吗？")])]),e._v(" "),t("p",[t("img",{attrs:{src:n(451),alt:"image"}}),e._v("\n这种加密方式称为对称加密，加密解密都是通过同一个密码来操作，所以需要保证密码的安全，一旦泄露，后果很严重.")]),e._v(" "),t("p",[e._v("还有更好的方法,那就使用两个密钥，一个用来加密（称为公钥），另一个用来解密（称为私钥），使用公钥加密过的内容，只能通过私钥进行解密。私钥只有自己有，公钥可以丢给别人。\n"),t("img",{attrs:{src:n(452),alt:"image"}}),e._v("\n这种加密方式称为非对称加密，会有二个钥匙，一个钥匙加密过的内容只能通过另一个钥匙进行解密。")]),e._v(" "),t("p",[t("img",{attrs:{src:n(453),alt:"image"}}),e._v("\n在聊天的过程中，小华发现消息发送和接收的时候很慢，后来发现因为是加密算法耗费比较长的时间。小华想了想，使用对称加密的时候，唯一的缺点是交换秘钥比较麻烦，但是速度非常快。那么可以通过非对称加密来传输对称加密的密钥，密钥传输成功后，使用对称加密来加密消息。")]),e._v(" "),t("p",[e._v("具体流程如下：\n"),t("img",{attrs:{src:n(454),alt:""}})]),e._v(" "),t("p",[e._v("HTTP 属于应用层协议，HTTPS 并不是一个新的协议，它只是比 HTTP 协议多了一层（TSL/SSL）来保证数据传输安全。TSL/SSL也属于协议，它的主要作用是保证数据传输安全。大多数使用的是 OpenSSL 来实现，比如 Node 中的 TSL 就是基于 OpenSSL 实现的")]),e._v(" "),t("h2",{attrs:{id:"http-2-新特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http-2-新特性"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://juejin.cn/post/6844903589635162120",target:"_blank",rel:"noopener noreferrer"}},[e._v("HTTP/2 新特性"),t("OutboundLink")],1)]),e._v(" "),t("ol",[t("li",[t("p",[e._v('二进制传输\nHTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。 HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。\n它把TCP协议的部分特性挪到了应用层，把原来的"Header+Body"的消息"打散"为数个小片的二进制"帧"(Frame),用"HEADERS"帧存放头数据、"DATA"帧存放实体数据。HTP/2数据分帧后"Header+Body"的报文结构就完全消失了，协议看到的只是一个个的"碎片"。')])]),e._v(" "),t("li",[t("p",[e._v("Header 压缩")])]),e._v(" "),t("li",[t("p",[e._v("多路复用")])]),e._v(" "),t("li",[t("p",[e._v("Server Push")])])]),e._v(" "),t("p",[t("strong",[e._v("总结：")])]),e._v(" "),t("ul",[t("li",[e._v("HTTP/1.1有两个主要的缺点：安全不足和性能不高。")]),e._v(" "),t("li",[e._v('HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS"，头部压缩、多路复用等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；')]),e._v(" "),t("li",[e._v("QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议")])]),e._v(" "),t("h2",{attrs:{id:"为什么使用token-session与token的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用token-session与token的区别"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://blog.csdn.net/mydistance/article/details/84545768",target:"_blank",rel:"noopener noreferrer"}},[e._v("为什么使用token？session与token的区别"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("strong",[e._v("session")]),e._v("\n当用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，验证成功后在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从数据库获取session数据，然后进行用户信息查询，查询到，就会将查询到的用户信息返回，从而实现状态保持。\n"),t("img",{attrs:{src:n(455),alt:"image"}})]),e._v(" "),t("p",[e._v("弊端：")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("服务器压力增大,通常session是存储在内存中的，每个用户通过认证之后都会将session数据保存在服务器的内存中，而当用户量增大时，服务器的压力增大。")])]),e._v(" "),t("li",[t("p",[e._v("CSRF跨站伪造请求攻击,session是基于cookie进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。")])]),e._v(" "),t("li",[t("p",[e._v("扩展性不强,如果将来搭建了多个服务器，虽然每个服务器都执行的是同样的业务逻辑，但是session数据是保存在内存中的（不是共享的），用户第一次访问的是服务器1，当用户再次请求时可能访问的是另外一台服务器2，服务器2获取不到session信息，就判定用户没有登陆过。")])])]),e._v(" "),t("p",[t("strong",[e._v("token认证机制")])]),e._v(" "),t("p",[e._v("token与session的不同主要在")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返还给客户端（服务器端并不进行保存）")])]),e._v(" "),t("li",[t("p",[e._v("浏览器会将接收到的token值存储在Local Storage中，（通过js代码写入Local Storage，通过js获取，并不会像cookie一样自动携带）")])]),e._v(" "),t("li",[t("p",[e._v("再次访问时服务器端对token值的处理：服务器对浏览器传来的token值进行解密，解密完成后进行用户数据的查询，如果查询成功，则通过认证，实现状态保持，所以，即时有了多台服务器，服务器也只是做了token的解密和用户数据的查询，它不需要在服务端去保留用户的认证信息或者会话信息，这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利，解决了session扩展性的弊端。\n"),t("img",{attrs:{src:n(456),alt:"image"}})])])]),e._v(" "),t("h2",{attrs:{id:"从输入url到看到页面发生了什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从输入url到看到页面发生了什么"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://juejin.cn/post/6844903832435032072#heading-128",target:"_blank",rel:"noopener noreferrer"}},[e._v("从输入URL到看到页面发生了什么？"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"dns-协议解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dns-协议解析"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://juejin.cn/post/6919755385330991112",target:"_blank",rel:"noopener noreferrer"}},[e._v("DNS 协议解析"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("strong",[e._v("完整域名解析过程")]),e._v("\n一个完整的 DNS 协议进行域名解析的过程。这里我们以正向解析为例（域名解析成 IP 地址）：")]),e._v(" "),t("ol",[t("li",[e._v("首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表；")]),e._v(" "),t("li",[e._v("若没有命中，则继续搜索操作系统的 DNS 缓存；")]),e._v(" "),t("li",[e._v("若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的 DNS 缓存，查找成功则返回结果（注意：主机和本地域名服务器之间的查询方式是递归查询）；")]),e._v(" "),t("li",[e._v("若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行迭代查询（注意：本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大）：")])]),e._v(" "),t("ul",[t("li",[e._v("首先本地域名服务器向根域名服务器发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案")]),e._v(" "),t("li",[e._v("本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址")]),e._v(" "),t("li",[e._v("本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址")])]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来")]),e._v(" "),t("li",[e._v("操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来")]),e._v(" "),t("li",[e._v("至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来")])]),e._v(" "),t("h2",{attrs:{id:"tcp三次握手与四次挥手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手与四次挥手"}},[e._v("#")]),e._v(" TCP三次握手与四次挥手")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://blog.csdn.net/qzcsu/article/details/72861891",target:"_blank",rel:"noopener noreferrer"}},[e._v("两张动图-彻底明白TCP的三次握手与四次挥手"),t("OutboundLink")],1)]),e._v(" "),t("h2",{attrs:{id:"网站攻击与防护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网站攻击与防护"}},[e._v("#")]),e._v(" 网站攻击与防护")]),e._v(" "),t("h3",{attrs:{id:"xss攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#xss攻击"}},[e._v("#")]),e._v(" XSS攻击")]),e._v(" "),t("p",[e._v("XSS攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。")]),e._v(" "),t("p",[t("strong",[e._v("攻击者可以通过这种攻击方式可以进行以下操作：")])]),e._v(" "),t("ul",[t("li",[e._v("获取页面的数据，如DOM、cookie、localStorage；")]),e._v(" "),t("li",[e._v("DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；")]),e._v(" "),t("li",[e._v("破坏页面结构；")]),e._v(" "),t("li",[e._v("流量劫持（将链接指向某网站）；")])]),e._v(" "),t("p",[t("strong",[e._v("攻击类型")]),e._v("\nXSS 可以分为存储型、反射型和 DOM 型：")]),e._v(" "),t("ul",[t("li",[e._v("存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。")]),e._v(" "),t("li",[e._v("反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。")]),e._v(" "),t("li",[e._v("DOM 型指的通过修改页面的 DOM 节点形成的 XSS。")])]),e._v(" "),t("p",[t("strong",[e._v("如何防御 XSS 攻击")]),e._v("\n可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：")]),e._v(" "),t("ul",[t("li",[e._v("可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。")]),e._v(" "),t("li",[e._v("使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。")])]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。")]),e._v(" "),t("li",[e._v("通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式")])])]),e._v(" "),t("ul",[t("li",[e._v("对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。")])]),e._v(" "),t("h3",{attrs:{id:"csrf-攻击"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#csrf-攻击"}},[e._v("#")]),e._v(" CSRF 攻击")]),e._v(" "),t("p",[e._v("CSRF 攻击指的是"),t("strong",[e._v("跨站请求伪造")]),e._v("攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。")]),e._v(" "),t("p",[e._v("CSRF 攻击的"),t("strong",[e._v("本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。")])]),e._v(" "),t("p",[t("strong",[e._v("如何防御 CSRF 攻击")])]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("进行同源检测")]),e._v("，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("使用 CSRF Token 进行验证")]),e._v("，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("对 Cookie 进行双重验证")]),e._v("，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("在设置 cookie 属性的时候设置 Samesite")]),e._v(" ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。")])])]),e._v(" "),t("h3",{attrs:{id:"网络劫持"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络劫持"}},[e._v("#")]),e._v(" ⽹络劫持")]),e._v(" "),t("p",[e._v("⽹络劫持分为两种:\n（1）DNS劫持: (输⼊京东被强制跳转到淘宝这就属于dns劫持)")]),e._v(" "),t("p",[e._v("DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器\n302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容")]),e._v(" "),t("p",[e._v("（2）HTTP劫持: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)")]),e._v(" "),t("h3",{attrs:{id:"防护"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防护"}},[e._v("#")]),e._v(" 防护")]),e._v(" "),t("ol",[t("li",[e._v("CSP (Content Security Policy)")])]),e._v(" "),t("p",[e._v("严格的 CSP 在 XSS 的防范中可以起到以下的作用：")]),e._v(" "),t("ul",[t("li",[e._v("禁止加载外域代码，防止复杂的攻击逻辑。")]),e._v(" "),t("li",[e._v("禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。")]),e._v(" "),t("li",[e._v("禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。")]),e._v(" "),t("li",[e._v("禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。")]),e._v(" "),t("li",[e._v("合理使用上报可以及时发现 XSS，利于尽快修复问题。")])]),e._v(" "),t("p",[e._v("两种方法可以启用 CSP。一种是通过 HTTP 头信息的"),t("code",[e._v("Content-Security-Policy")]),e._v("的字段。另一种是通过网页的"),t("code",[e._v("<meta>")]),e._v("标签。")])])}),[],!1,null,null,null);t.default=r.exports}}]);