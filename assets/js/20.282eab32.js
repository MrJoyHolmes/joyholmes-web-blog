(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{466:function(e,n,t){e.exports=t.p+"assets/img/20210427092235823.bc1f876e.png"},493:function(e,n,t){"use strict";t.r(n);var a=t(2),s=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"项目相关"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目相关"}},[e._v("#")]),e._v(" 项目相关")]),e._v(" "),n("h2",{attrs:{id:"封装网络请求"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#封装网络请求"}},[e._v("#")]),e._v(" 封装网络请求")]),e._v(" "),n("ol",[n("li",[e._v("使用拦截器对请求和相应进行处理")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  axios.interceptors.response.use(\n    (res:any) => {\n        return Promise.resolve(res);\n    },\n    (error: any) => {\n        if (error.response.status && error.response.status  == "401") {\n            Vue.prototype.$message.closeAll();\n            Vue.prototype.$message({\n                type: \'warning\',\n                message: "长时间未操作,需要重新登录!"\n            });\n            window.sessionStorage.setItem("token", "");\n            router.replace("/");\n            console.clear();\n            return;\n        }\n        return Promise.resolve(error.response);\n    }\n  );\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("设置通用的配置，添加到每一个请求(baseURL, timeout)")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  abstract class ServiceBase {\n    private static globalSource: CancelTokenSource = axios.CancelToken.source();\n    public static config: AxiosRequestConfig = {\n        baseURL: (window as any).facilityParams.serverUrl,\n        timeout: 10000,\n        cancelToken: ServiceBase.globalSource.token\n    };\n\n    private static _serviceHandler(res: any) {\n        let msg = "";\n        if (!res) {\n            msg = "无响应结果";\n            console.log(msg);\n            return null;\n        }\n        if (res.data && res.data.hasError) {\n            msg = `错误信息${res.data.message}`;\n            console.log(msg);\n            return null;\n        }\n        return res.data;\n    }\n\n    protected static _post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {\n        return axios\n            .post(url, data, { ...ServiceBase.config, ...config })\n            .then(ServiceBase._serviceHandler)\n            .catch((err: any) => {\n                const msg = `请求${url}出错`;\n                console.error(msg, err);\n            });\n    }\n\n    protected static _download<T>(url: string, params: any) {\n        const devMode = process.env.NODE_ENV === "development";\n        if(devMode){\n            window.open("http://localhost:8008" + "/" + url + `/?${qs.stringify(params)}`);\n        } else {\n            window.open((window as any).facilityParams.facilityServerUrl + "/" + url + `/?${qs.stringify(params)}`);\n        }\n    }\n  }\n')])])]),n("ol",{attrs:{start:"3"}},[n("li",[e._v("请求调用")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  import ServiceBase from "./service-base";\n  import qs from "qs";\n  class PumpStationService extends ServiceBase {\n      static getRegionList(params: any) {\n          return this._get(`/home/dr/region/type?${qs.stringify(params)}`);\n      }\n      static pumpStationAdd(params: any) {\n          return this._post(`/home/dr/pumpstation/add`, params);\n      }\n      static pumpStationUpdate(params: any) {\n          return this._post(`/home/dr/pumpstation/update`, params);\n      }\n      static pumpStationDelete(params: any) {\n          return this._post(`/home/dr/pumpstation/delete?${qs.stringify(params)}`, {});\n      }\n  }\n  export default PumpStationService;\n')])])]),n("h2",{attrs:{id:"打包优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打包优化"}},[e._v("#")]),e._v(" 打包优化")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://juejin.cn/post/6844904093463347208#heading-12",target:"_blank",rel:"noopener noreferrer"}},[e._v("带你深度解锁 Webpack 系列(优化篇)"),n("OutboundLink")],1)]),e._v(" "),n("blockquote",[n("p",[e._v("vue-cli-service build --report 获取打包 bundle 信息")])]),e._v(" "),n("h3",{attrs:{id:"ignoreplugin-优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ignoreplugin-优化"}},[e._v("#")]),e._v(" "),n("strong",[e._v("IgnorePlugin 优化")])]),e._v(" "),n("p",[e._v("webpack  的内置插件，作用是忽略第三方包指定目录。例如: moment (2.24.0 版本)  会将所有本地化内容和核心功能一起打包，我们就可以使用  IgnorePlugin  在打包时忽略本地化内容。（优化打包体积）以 drainageMonitor 为例，使用该方法可以微弱减小打包体积。(19.3--\x3e18.9)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let Webpack = require('webpack');\nplugins:[\n\tnew Webpack.IgnorePlugin(/\\.\\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去\n]\n")])])]),n("p",[e._v("我们虽然按照上面的方法忽略了包含’./locale/'该字段路径的文件目录,但是也使得我们使用的时候不能显示中文语言了，所以这个时候可以手动引入中文语言的目录")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import moment from 'moment'\n\n//设置语言\n\n//手动引入所需要的语言包\nimport 'moment/locale/zh-cn';\n\nmoment.locale('zh-cn');\n\nlet r = moment().endOf('day').fromNow();\nconsole.log(r);\n\n")])])]),n("h3",{attrs:{id:"externals-使用-cdn-加速优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#externals-使用-cdn-加速优化"}},[e._v("#")]),e._v(" "),n("strong",[e._v("externals 使用 CDN  加速优化")])]),e._v(" "),n("p",[e._v("cdn 优化是指把第三方库比如（vue，vue-router，axios）通过 cdn 的方式引入项目中，这样 vendor.js 会显著减少，并且大大提升项目的首页加载速度。\n     使用该方法可以极大地优化打包体积。还是以 drainageMonitor 为例将下面几个模块使用 CDN 优化，打包体积几乎缩小到一半。目前使用该方法打包的前端代码可以正常运行，但须进一步测试具体功能，以及解决不同版本的 npm 包可能带来的问题，所以暂未提交代码。(18.9--\x3e11.2)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//webpack.config.js\n  module.exports = {\n      //...\n      externals: {\n          //jquery通过script引入之后，全局中即有了 jQuery 变量\n          'jquery': 'jQuery'\n      }\n  }\n\n  'vue': 'Vue',\n  \"element-ui\": \"ELEMENT\",\n  'vue-router': 'VueRouter',\n  'axios': 'axios',\n  'echarts': 'echarts',\n")])])]),n("p",[e._v("打包之后查看相关请求，相同网络条件下使用 cdn 优化打包的 echarts.js 请求时间为 287 毫秒，使用原来方式请求单独打包的 echarts.js 请求时间为 1.09 秒，请求时间优化效果也非常明显。")]),e._v(" "),n("p",[e._v("可以使用该方法将 report.html 中体积较大的其他引用（xlsx，yxg-xlsx-style）进一步优化打包体积。同时，可以看到几乎每个 js 打包文件中都有 jquery，并且所占体积也不小，可以将 jquery 进行单独打包优化，或者使用 cdn 方式优化。")]),e._v(" "),n("blockquote",[n("p",[e._v("项目使用了线上开源的 CDN 却因为服务不稳定导致了团队项目出现问题的情况,在一次迭代中统一替换成了 webpack-dll-plugin")])]),e._v(" "),n("h3",{attrs:{id:"npm-run-dll-优化打包速度"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm-run-dll-优化打包速度"}},[e._v("#")]),e._v(" "),n("strong",[e._v("npm run dll(优化打包速度)")])]),e._v(" "),n("ol",[n("li",[e._v("dll 优化原理:\n每次打包都会处理所有的内容，但是并不更改第三方包(vue/jquery/axios 等等),那么 dll 先打包第三方报，告诉真正的包那些第三方包已经被处理了，下次就不用再打包了")]),e._v(" "),n("li",[e._v("在 build 文件下新建一个 webpack.dll.js 文件,\n内容如下")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const path = require(\"path\")\nconst webpack = require(\"webpack\")\nmodule.exports = {\n    entry:{\n        vendor:['vue/dist/vue.esm','vue-router','axios','jquery']\n    },\n    output:{\n        path:path.join(__dirname,'../static/js'),\n        filename:'[name].dll.js',\n        library:'[name]_library'\n    },\n    plugins:[\n        new webpack.DllPlugin({\n            path:path.join(__dirname,\"../static/js/vendor-manifest.json\"),\n            name:\"[name]_library\"\n        })\n    ]\n}\n")])])]),n("p",[e._v("npm run dll\nnpm run build")]),e._v(" "),n("h3",{attrs:{id:"提取第三方库-公共代码-optimization-splitchunks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#提取第三方库-公共代码-optimization-splitchunks"}},[e._v("#")]),e._v(" "),n("strong",[e._v("提取第三方库(公共代码)---optimization.splitChunks")])]),e._v(" "),n("p",[e._v("由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。 这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  config.optimization.splitChunks({\n  chunks: "all",\n  cacheGroups: {\n      // 单独优化xlsx依赖，使之只打包一次,\n      xlsx: {\n          name: "xlsx",\n          test: /[\\\\/]node_modules[\\\\/]xlsx[\\\\/]/,\n          minSize: 0,\n          minChunks: 1,\n          reuseExistingChunk: true,\n          chunks: "all"\n      },\n      yxgxlsxstyle: {\n          name: "yxg-xlsx-style",\n          test: /[\\\\/]node_modules[\\\\/]yxg-xlsx-style[\\\\/]/,\n          minSize: 0,\n          minChunks: 1,\n          reuseExistingChunk: true,\n          chunks: "all"\n      },\n      elementUI: {\n          name: "chunk-elementUI", // 单独将 elementUI 拆包\n          priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app\n          test: /[\\\\/]node_modules[\\\\/]element-ui[\\\\/]/\n      },\n      echarts: {\n          name: "chunk-echarts", // 单独将 echarts 拆包\n          priority: 20, // 权重要大于 libs 和 app 不然会被打包进 libs 或者 app\n          test: /[\\\\/]node_modules[\\\\/]echarts[\\\\/]/\n      }\n  }\n});\n')])])]),n("ul",[n("li",[e._v("test: 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String 和 Function;")]),e._v(" "),n("li",[e._v("priority：表示抽取权重，数字越大表示优先级越高。因为一个 module 可能会满足多个 cacheGroups 的条件，那么抽取到哪个就由权重最高的说了算；")]),e._v(" "),n("li",[e._v("reuseExistingChunk：表示是否使用已有的 chunk，如果为 true 则表示如果当前的 chunk 包含的模块已经被抽取出去了，那么将不会重新生成新的。")]),e._v(" "),n("li",[e._v("minChunks（默认是 1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）")]),e._v(" "),n("li",[e._v("chunks (默认是 async) ：initial、async 和 all")]),e._v(" "),n("li",[e._v("name(打包的 chunks 的名字)：字符串或者函数(函数可以根据条件自定义名字)")])]),e._v(" "),n("h2",{attrs:{id:"文件上传下载预览"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件上传下载预览"}},[e._v("#")]),e._v(" 文件上传下载预览")]),e._v(" "),n("h3",{attrs:{id:"文件上传"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件上传"}},[e._v("#")]),e._v(" 文件上传")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  //文件上传\n  <div class="equip-upload"  v-if="!editFlag">\n      <el-upload\n          ref="upload1"\n          class="upload-btn"\n          :auto-upload="false"\n          :data="uploadData1"\n          :action="uploadUrl"\n          name="files"\n          :limit="1"\n          :on-exceed="handleExceed"\n          :headers="setUploadHeader"\n          :on-error="handleUploadError"\n          :before-remove="beforeRemove1"\n          :on-change="onChange"\n          :file-list="fileList1"\n          :before-upload="beforeFileUpload"\n      >\n          <el-button style="border: #3388ff 1px solid" plain icon="el-icon-upload2">点击上传</el-button>\n      </el-upload>\n  </div>\n\n  protected handleUploadError() {\n        this.$message.error("上传附件失败!");\n    }\n\n    protected beforeRemove1(file: any, fileList: any) {\n        if (file.mediaID) {\n            MediaService.deleteMedia({ mediaID: file.mediaID })\n                .then((data: any) => {\n                    if (data?.success) {\n                        this.$message.success("附件删除成功");\n                        return;\n                    }\n                    this.$message.error("附件删除失败");\n                })\n                .catch(() => {\n                    this.$message.error("附件删除失败");\n                });\n        }\n        return true;\n    }\n\n    protected handleExceed(files: any, fileList: any) {\n        this.$message.warning(\n            `当前限制选择 1 个文件，本次选择了 ${files.length} 个文件，共选择了 ${files.length + fileList.length} 个文件`\n        );\n    }\n\n    protected onChange(file: any) {\n        const isFileValid = floodReportFileTypeValid(file.name);\n        const isLt2M = file.size / 1024 / 1024 < 30;\n        const fileName = file.name.split(".")[0];\n        const isFileNameValid = fileName.length < 100;\n        if (!isFileValid) {\n            this.$message.error("不支持上传文件格式!");\n            this.fileList1 = [];\n            return;\n        }\n        if (!isLt2M) {\n            this.$message.error("文件过大!");\n            this.fileList1 = [];\n            return;\n        }\n        if (!isFileNameValid) {\n            this.$message.error("文件名过长！");\n            this.fileList1 = [];\n        }\n    }\n\n    protected beforeFileUpload(file: any) {\n        const isFileValid = floodReportFileTypeValid(file.name);\n        const isLt2M = file.size / 1024 / 1024 < 30;\n        const fileName = file.name.split(".")[0];\n        const isFileNameValid = fileName.length < 100;\n        if (!isFileValid) {\n            this.$message.error("不支持上传文件格式!");\n        }\n        if (!isLt2M) {\n            this.$message.error("文件过大!");\n        }\n        if (!isFileNameValid) {\n            this.$message.error("文件名过长！");\n        }\n        return isFileValid && isLt2M && isFileNameValid;\n    }\n\n    //常见文件格式验证\n    export function isFileTypeValid(fileName: any) {\n        if (fileName == null || fileName == "") {\n            return false;\n        }\n        if (fileName.lastIndexOf(".") == -1) {\n            return false;\n        }\n        const AllExt = ".png|.jpe|.jpeg|.jpg|.gif|.txt|.html|.htm|.csv|.xml|.mp3|.mp4|.doc|.docx|.xls|.xlsx|.ppt|.pptx|.pdf|";\n        const extName = fileName.substring(fileName.lastIndexOf(".")).toLowerCase(); //（把路径中的所有字母全部转换为小写）\n        if (AllExt.indexOf(extName) == -1) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n')])])]),n("h3",{attrs:{id:"文件预览"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件预览"}},[e._v("#")]),e._v(" 文件预览")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    //文件预览\n    <el-dialog\n        :modal-append-to-body="false"\n        :append-to-body="false"\n        :title="previewTitle"\n        :visible.sync="dialogVisible"\n        :close-on-click-modal="false"\n        class="edit-dialog"\n        :before-close="closePreview"\n        :destroy-on-close="true"\n    >\n        <FileWatch :docSrc="docSrc" :mediaType="mediaType"></FileWatch>\n    </el-dialog>\n\n    protected showPatch() {\n        if (!this.rowData.id){\n            return;\n        }\n        const param = { ...{ relationTypeID: this.reportTypeID }, ...{ relationID: this.rowData.id } };\n        MediaService.getMedia(param).then((imgData: any) => {\n            this.mediaType = "";\n            if (imgData?.success) {\n                const mediaList = imgData?.data?.mediaList || [];\n                if (mediaList?.length) {\n                    this.docSrc = `${(window as any).facilityParams.facilityServerUrl}/${mediaList[0].mediaURL}`;\n                    this.mediaType = this.docSrc.substring(this.docSrc.lastIndexOf(".") + 1);\n                }\n                if (this.mediaType === "xlsx" || this.mediaType === "xls" || this.mediaType === "doc" || this.mediaType === "docx") {\n                    this.formSubmit(this.docSrc);\n                } else {\n                    this.dialogVisible = true;\n                }\n            }\n        });\n    }\n    protected formSubmit(url: any) {\n        const a = document.createElement("a");\n        a.style.display = "none";\n        a.href = url;\n        a.download = "附件";\n        document.body.appendChild(a);\n        a.click();\n        document.body.removeChild(a);\n    }\n\n    //FileWatch.vue\n    <el-dialog :title="previewTitle" :visible.sync="dialogPdfVisible" class="g-dialog previewDialog" @close=\'closePreview\'>\n        <iframe :src="docUrl" width="100%" ref="previewIframe" height="100%" v-if="this.mediaType == \'TEXT\'"></iframe>\n        <el-image style="width: 100%; height: 100%" :src="docUrl" fit="contain" v-if="this.mediaType == \'IMAGE\'"></el-image>\n        <video\n            id="myVideo"\n            class="video-js vjs-default-skin vjs-big-play-centered"\n            controls\n            preload="auto"\n            muted\n            autoplay="autoplay"\n            style="width: 100%;height: 100%;object-fit: fill"\n            v-if="this.mediaType == \'VIDEO\'"\n        ></video>\n        <audio autoplay="autoplay" \n            controls="controls"\n            preload="auto"\n            v-if="this.mediaType == \'AUDIO\'"\n            style="clear:both;display:block;margin:1.5rem auto"\n            :src="docUrl">\n        </audio>\n    </el-dialog>\n')])])]),n("h3",{attrs:{id:"文件导出"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#文件导出"}},[e._v("#")]),e._v(" 文件导出")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('    protected downloadItems() {\n        ExportUtils.exportData(this.columns, this.tableData, "重点区域管理");\n    }\n\n\n    import moment from "moment";\n    import excel from "@/utils/export2Excel";\n    export default class ExportUtils {\n        /* 前端导出 */\n        public static exportData(columns: any, tableData: any, fieldName: any, timeFields?: any) {\n            if (tableData.length == 0) return;\n            const header: any = [];\n            columns.forEach((item: any) => {\n                header.push(item.label);\n            });\n            const data: any = tableData.map((v: any) =>\n                columns.map((j: any) => {\n                    if(v[j["field"]] === "" || v[j["field"]] === null){\n                        v[j["field"]] = "-";\n                    } else if (timeFields && timeFields?.length && timeFields.indexOf(j["field"]) > -1) {\n                        v[j["field"]] =  moment(v[j["field"]]).format("YYYY-MM-DD");\n                    }\n                    return v[j["field"]];\n                })\n            );\n            excel.export_json_to_excel({\n                header,\n                data,\n                filename: fieldName + moment().format("YYYY-MM-DD_HHmmss"),\n                autoWidth: true,\n                bookType: "xlsx"\n            });\n        }\n    }\n\n\n    // import XLSX from "xlsx";\n    import XLSX from "yxg-xlsx-style";\n    import moment from "moment";\n\n\n')])])]),n("h2",{attrs:{id:"常用内容模块化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用内容模块化"}},[e._v("#")]),e._v(" 常用内容模块化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  //文件操作模块\n  import OperateBtn from "@/components/common/operateBtn/OperateBtn.vue";\n\n  protected btnList = [\n    { name: "新增", icon: "icon-add", color: "#3488FF", showBtn: true, btnClick: this.addItem },\n    { name: "编辑", icon: "icon-edit", color: "#3488FF", showBtn: false, btnClick: this.editItem, checkStyle: "single" },\n    { name: "删除", icon: "icon-delete", color: "#FF4545", showBtn: false, btnClick: this.deleteItem, checkStyle: "multiple" },\n    { name: "下载模板", icon: "icon-daoru", color: "#3488FF", showBtn: true, btnClick: this.downloadTemplate },\n    { name: "导入", icon: "icon-import", color: "#11C79B", showBtn: true, btnClick: this.importData },\n    { name: "导出", icon: "icon-download", color: "#11C79B", showBtn: true, btnClick: this.downloadItems }\n  ];\n\n  <OperateBtn :btnList="btnList"></OperateBtn>\n\n\n  //通用表格模块\n  import TableList from "@/components/test/TableList.vue";\n  <div class="table-wrap">\n      <TableList :columnList="columnList" :tableData="tableData" :total="total"/>\n  </div>\n\n  @Prop({ type: Array, default: [] })\n  protected columns!: any;\n\n  @Prop({ type: Boolean, default: false })\n  protected showSelection!: any;\n\n  @Prop({ type: Number, default: 10 })\n  protected pageSize!: any;\n\n  @Prop()\n  protected serviceBase!: any;\n\n  @Prop({ type: String, default: "" })\n  protected urlMethod!: any;\n\n  @Prop({ type: Object, default: {} })\n  protected params!: any;\n\n\n  //通用菜单模块\n  import Menus from "@/components/common/leftMenu/LeftMenu.vue";\n\n  <aside>\n      <Menus :menusList="menusList" :collapse="collapse"></Menus>\n  </aside>\n\n\n')])])]),n("h2",{attrs:{id:"videojs播放视频"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#videojs播放视频"}},[e._v("#")]),e._v(" videojs播放视频")]),e._v(" "),n("p",[e._v("前端在浏览器显示摄像头传回的RTSP视频流，我和后端都没做过视频流的项目，所以一步步摸索过来，方法和经验供大家参考。前端采用的技术有VUE+video.js+flv.js")]),e._v(" "),n("p",[n("img",{attrs:{src:t(466),alt:""}})]),e._v(" "),n("p",[n("strong",[e._v("几种视频流的播放方法")])]),e._v(" "),n("ol",[n("li",[e._v("RTSP")])]),e._v(" "),n("p",[e._v("从上图可以看出，RTSP流不能直接在浏览器播放，所以需要转码：")]),e._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[e._v("RTSP转RTMP")])]),e._v(" "),n("p",[e._v("RTMP的流需要在浏览器中用flash播放器，但是谷歌已经在2020年底带头不支持flash插件了")]),e._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[e._v("RTSP转HLS(视频中台)")])]),e._v(" "),n("p",[e._v("后端将视频转成HLS流，以m3u8后缀结尾。通过浏览器用video.js可以正常播放，但是发现和原视频存在5秒左右的延迟，不符合项目的实时性需求，所以有实时视频的需求不建议用HLS流播放。下面提供几个HLS的测试地址：\nhttp://ivi.bupt.edu.cn/hls/cctv1hd.m3u8（CCTV-1到CCTV-14，改为相应cctv1hd就可以）\nhttp://ivi.bupt.edu.cn/hls/hunanhd.m3u8（湖南卫视高清）\nhttp://ivi.bupt.edu.cn/hls/btv1hd.m3u8（北京卫视高清）")]),e._v(" "),n("ol",{attrs:{start:"4"}},[n("li",[e._v("RTSP转FLV")])]),e._v(" "),n("p",[e._v("经过和后端不断讨论，最后决定用RTSP转flv格式的方案来播放视频。flv.js是一个较成熟的前端处理flv格式的插件库，是B站视频的开源插件。")]),e._v(" "),n("h2",{attrs:{id:"动态路由"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#动态路由"}},[e._v("#")]),e._v(" 动态路由")]),e._v(" "),n("ol",[n("li",[e._v("根据seniorItemName和humanID向后台获取路由相关数据")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  const humannavPromise: any = humannav({\n      fn:(view:string)=>{\n          return () => import(`@/views/landscaping/${view}.vue`);\n      },\n      seniorItemName:"lsgreenland"\n  });\n  humannavPromise.then((router: any) => {\n      new Vue({\n          router,\n          store,\n          render: h => h(App)\n      }).$mount("#app");\n  })\n\n  navdata = await CommonService.humannav({ seniorItemName: seniorName });\n\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("根据返回的数据构造appMenu")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  const { router } = getAppMenu({ humanNavBarItems, extraNav: obj.extraNav });\n\n    // 获取一级菜单\n    const virtualRoutes: any = [];\n    const rootObj = getRoot(humanNavBarItems);\n\n    humanNavBarItems.forEach((item: any) => {\n        if (item.seniorID == rootObj.navItemID && item.navItemName) {\n            virtualRoutes.push(item);\n        }\n    });\n\n    // 根据后台获取的一级菜单对象，构造真实的一级路由\n    virtualRoutes.forEach((virtualRoute: any) => {\n        const routeObj = createRouteObj(virtualRoute);\n        realRoutes.push(routeObj);\n    });\n\n    //遍历真实一级菜单，构造真实二级、三级等子菜单\n    realRoutes.forEach((realRoute: any) => {\n        generateAllRoutes(realRoute, humanNavBarItems, obj.extraNav);\n    });\n")])])]),n("h2",{attrs:{id:"scss-mixin-scss"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#scss-mixin-scss"}},[e._v("#")]),e._v(" scss _mixin.scss")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    @mixin size($width: 100%, $height: 100%) {\n        width: $width;\n        height: $height;\n    }\n\n    /* --------------------------------------------\n    flex布局\n    ---------------------------------------------*/\n    @mixin flex($row: row, $justify-content: flex-start, $align-items: flex-start, $wrap: nowrap) {\n        display: flex;\n        flex-flow: $row $wrap;\n        justify-content: $justify-content;\n        align-items: $align-items;\n    }\n\n    /* --------------------------------------------\n    省略号\n    ---------------------------------------------*/\n    @mixin ellipsis() {\n        overflow: hidden;\n        -ms-text-overflow: ellipsis;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    /* --------------------------------------------\n    自定义行数省略号\n    ---------------------------------------------*/\n    @mixin multiellipsis($line) {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        display: -webkit-box;\n        -webkit-line-clamp: $line; //行数\n        -webkit-box-orient: vertical;\n    }\n\n    /* --------------------------------------------\n    绝对定位\n    ---------------------------------------------*/\n    @mixin absolute($top: unset, $right: unset, $bottom: unset, $left: unset) {\n        position: absolute;\n        top: $top;\n        left: $left;\n        bottom: $bottom;\n        right: $right;\n    }\n")])])]),n("h2",{attrs:{id:"首屏优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#首屏优化"}},[e._v("#")]),e._v(" 首屏优化")]),e._v(" "),n("h3",{attrs:{id:"打包分析"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#打包分析"}},[e._v("#")]),e._v(" 打包分析")]),e._v(" "),n("p",[e._v('在 package.json 中添加命令 "report": "vue-cli-service build --report"')]),e._v(" "),n("p",[e._v("然后命令行执行 npm run report，就会在dist目录下生成一个 report.html 文件，右键浏览器中打开即可看到打包分析报告。")]),e._v(" "),n("h3",{attrs:{id:"路由懒加载"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载"}},[e._v("#")]),e._v(" 路由懒加载")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('component: () => import("views/home/Home.vue"),\n')])])]),n("h3",{attrs:{id:"vue-config-js-修改-productionsourcemap"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#vue-config-js-修改-productionsourcemap"}},[e._v("#")]),e._v(" vue.config.js 修改 productionSourceMap")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("productionSourceMap: devMode ? true : false,\n")])])]),n("h3",{attrs:{id:"prefetch、preload"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prefetch、preload"}},[e._v("#")]),e._v(" Prefetch、Preload")]),e._v(" "),n("blockquote",[n("p",[n("code",[e._v("<link>")]),e._v("标签的rel属性的两个可选值。"),n("br"),e._v(" "),n("strong",[e._v("Prefetch")]),e._v("，预请求，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器有可能通过事先获取和缓存对应资源，优化用户体验。"),n("br"),e._v(" "),n("strong",[e._v("Preload")]),e._v("，预加载，表示用户十分有可能需要在当前浏览中加载目标资源，所以浏览器必须预先获取和缓存对应资源。")])]),e._v(" "),n("p",[e._v("Prefetch、Preload可以在某些场景下可以有效优化用户体验。举些场景:")]),e._v(" "),n("ol",[n("li",[e._v("首屏字体、大图加载，CSS中引入字体需要等CSS解析后才会加载，这之前浏览器会使用默认字体，当加载后会替换为自定义字体，导致字体样式闪动，而我们使用Preload提前加载字体后这种情况就好很多了，大图也是如此")]),e._v(" "),n("li",[e._v("优惠券的背景图加载，同样CSS中url引用在DOM没挂载之前是不会加载图片的，进入卡包页/收银台时可以提前使用Prefetch加载，这样用户在进行优惠券页就可以立马看到加载完成的图片了")])]),e._v(" "),n("p",[e._v("Vue-Cli3默认会使用preload-webpack-plugin对chunk资源做preload、prefetch处理，入口文件preload，路由chunk则是prefetch。")]),e._v(" "),n("p",[e._v("一般来说不需要做特别处理，如果判断不需要或者需要调整在vue.config.js中配置即可")]),e._v(" "),n("p",[e._v("理论上prefetch不会影响加载速度，但实际测试中，是有轻微影响的，不过这个见仁见智，我认为总体体验上还是有所提升的，\n类似字体文件这种隐藏在脚本、样式中的首屏关键资源，建议使用preload，移动端流量访问时慎用")]),e._v(" "),n("h3",{attrs:{id:"图片压缩"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#图片压缩"}},[e._v("#")]),e._v(" 图片压缩")]),e._v(" "),n("p",[e._v("使用 image-minimizer-webpack-plugin")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://xxpromise.gitee.io/webpack5-docs/senior/reduceVolume.html#image-minimizer",target:"_blank",rel:"noopener noreferrer"}},[e._v("Image Minimizer"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"cdn优化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cdn优化"}},[e._v("#")]),e._v(" CDN优化")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("  //vue.config.js\n  configureWebpack: config => {\n    config.resolve = {\n      // 使用 CDN 的包不用打包到文件中\n      externals: {\n        // 这里的 element-ui 是 import xx from yy 中的 yy 包名。ELEMENT 则是文件导出的全局变量名字\n        'element-ui': 'ELEMENT',\n      },\n    },\n  },\n  chainWebpack: config => {\n    // 添加 CDN 参数到 htmlWebpackPlugin 配置中\n    config.plugin('html').tap(args => {\n      args[0].cdn = {\n        js: [\n          'https://xx.com/CDN/js/index-element-ui@2.13.0.js',\n        ],\n        css: [\n          'https://xx.com/CDN/css/element-ui2.13.0/index.css',\n        ],\n      };\n      return args;\n    });\n  },\n\n")])])]),n("p",[e._v("然后在 index.html 中挂载 CDN")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  <!DOCTYPE html>\n  <html lang="zh">\n    <head>\n      <% for (var i in htmlWebpackPlugin.options.cdn&&htmlWebpackPlugin.options.cdn.css) { %>\n      <link href="<%= htmlWebpackPlugin.options.cdn.css[i] %>" rel="preload" as="style">\n      <link href="<%= htmlWebpackPlugin.options.cdn.css[i] %>" rel="stylesheet">\n      <% } %>\n      \x3c!-- 使用 CDN 加速的 JS 文件，配置在 vue.config.js 下 --\x3e\n      <% for (var i in htmlWebpackPlugin.options.cdn&&htmlWebpackPlugin.options.cdn.js) { %>\n      <script src="<%= htmlWebpackPlugin.options.cdn.js[i] %>" type="text/javascript"><\/script>\n      <% } %>\n    </head>\n    <body>\n      <div id="app"></div>\n    </body>\n  </html>\n\n')])])]),n("h3",{attrs:{id:"公共代码抽离"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#公共代码抽离"}},[e._v("#")]),e._v(" 公共代码抽离")]),e._v(" "),n("p",[e._v("splitChunk")]),e._v(" "),n("h3",{attrs:{id:"开启-gzip-压缩"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#开启-gzip-压缩"}},[e._v("#")]),e._v(" 开启 gzip 压缩")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("npm install compression-webpack-plugin --save-dev\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("//vue.config.js\nconst CompressionPlugin = require('compression-webpack-plugin');\n \nmodule.exports = {\n  configureWebpack: config => {\n    config.plugins = [\n      ...config.plugins,\n      // 开启 gzip 压缩\n      new CompressionPlugin({\n        filename: '[path][base].gz',\n        algorithm: 'gzip',\n       test: /\\.js$|\\.html$|\\.css$|\\.jpg$|\\.jpeg$|\\.png/, // 需要压缩的文件类型\n        threshold: 10240,\n        minRatio: 0.8\n      })\n    ]\n  }\n}\n\n")])])]),n("p",[e._v("nginx要进行相应配置")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("http {\n\n   gzip on; # 开启 gzip 压缩\n   gzip_static on; # 若存在静态 gz 文件，则使用该文件\n   gzip_min_length 10k; # 设置允许压缩的页面最小字节数\n   gzip_buffers 16 8k; # 设置用于处理请求压缩的缓冲区数量和大小\n   gzip_comp_level 1; # 设置压缩级别 1-9，数字越大，压缩后的大小越小，也越占用CPU，花费时间越长\n   # 对特定的 MIME 类型生效, 其中'text/html’被系统强制启用\n   gzip_types application/javascript text/css font/ttf font/x-woff;\n   gzip_vary on; # 是否在 http header中 添加 Vary:Accept-Encoding, on | off\n   gzip_http_version 1.1; # 在 http/1.1 的协议下不开启压缩\n}\n\n")])])]),n("p",[e._v("资源响应头中出现 Content-Encoding: gzip 则代表配置成功")]),e._v(" "),n("h2",{attrs:{id:"rem布局"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rem布局"}},[e._v("#")]),e._v(" rem布局")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 设置echarts文本自适应\n  (window as any).pumpScale = document.documentElement.clientWidth / 1920;\n\n  const option: any = {\n    grid: [{\n        left: 45 * (window as any).pumpScale,\n        right: 30 * (window as any).pumpScale,\n        top: 30 * (window as any).pumpScale,\n        height: '33%'\n    }, {\n        left: 45 * (window as any).pumpScale,\n        right: 30 * (window as any).pumpScale,\n        top: '47%',\n        height: '33%'\n    }]\n  }\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('  (function() {\n    const baseSize = 1920;\n    window.baseSize = baseSize;\n    function setRem() {\n      let scale = document.documentElement.clientWidth / baseSize;\n      document.documentElement.style.fontSize = scale * 100 + "px";\n    }\n\n    setRem();\n    window.onresize = function() {\n      setRem();\n    };\n  })();\n')])])]),n("h2",{attrs:{id:"其他注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他注意事项"}},[e._v("#")]),e._v(" 其他注意事项")]),e._v(" "),n("ul",[n("li",[e._v("public/init.js 中初始化了一些参数存储在 window.facilityParams 中，这些参数会在各模块 main.ts 中进一步初始化")]),e._v(" "),n("li",[e._v("提交打包后文件至智云仓库时请删除 report.html")]),e._v(" "),n("li",[e._v("编码 ts 时多使用接口（interface），使用明确的类型而不是 any")]),e._v(" "),n("li",[e._v("编写 css 时建议多使用混合器（Mixin）和函数")]),e._v(" "),n("li",[e._v("在 vue.config.js 中设置开发环境的代理，请不要提交本地代理")]),e._v(" "),n("li",[e._v("使用微服务作为后台的模块可能会涉及调用多个后台地址，比如通过代理调用 mis 后台，通过代理调用物联网接口，请注意调用正确的后台地址，相关服务初始化在 util/config.ts 文件里，请仔细阅读")])])])}),[],!1,null,null,null);n.default=s.exports}}]);