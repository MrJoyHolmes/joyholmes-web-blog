(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{458:function(t,_,v){t.exports=v.p+"assets/img/TCP_IP.36b80e09.jpg"},459:function(t,_,v){t.exports=v.p+"assets/img/TCP_IP2.8819003f.jpg"},460:function(t,_,v){t.exports=v.p+"assets/img/TCP_IP3.6bd49478.jpg"},461:function(t,_,v){t.exports=v.p+"assets/img/TCP_UDP.59f117ab.png"},462:function(t,_,v){t.exports=v.p+"assets/img/TCP_yongsebimian.90842386.jpg"},463:function(t,_,v){t.exports=v.p+"assets/img/TCP_kuaisuhuifu.3d4357db.jpg"},464:function(t,_,v){t.exports=v.p+"assets/img/http2headers.7bad6229.jpg"},465:function(t,_,v){t.exports=v.p+"assets/img/keep-alive.2d7186d8.jpg"},492:function(t,_,v){"use strict";v.r(_);var a=v(2),s=Object(a.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"前端网络知识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端网络知识"}},[t._v("#")]),t._v(" 前端网络知识")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.cn/post/6908327746473033741",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端计算机网络"),_("OutboundLink")],1),t._v(" "),_("a",{attrs:{href:"https://juejin.cn/post/7197070078360322109",target:"_blank",rel:"noopener noreferrer"}},[t._v("常见计算机网络问题"),_("OutboundLink")],1)]),t._v(" "),_("h2",{attrs:{id:"tcp-ip五层协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip五层协议"}},[t._v("#")]),t._v(" TCP/IP五层协议")]),t._v(" "),_("p",[t._v("TCP/IP五层协议和OSI的七层协议对应关系如下：\n"),_("img",{attrs:{src:v(458),alt:""}})]),t._v(" "),_("ul",[_("li",[_("p",[t._v("应用层 (application layer)：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。")])]),t._v(" "),_("li",[_("p",[t._v("传输层 (transport layer)：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：")]),t._v(" "),_("ul",[_("li",[t._v("传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）")]),t._v(" "),_("li",[t._v("用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。")])])]),t._v(" "),_("li",[_("p",[t._v("网络层 (internet layer)：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。")])]),t._v(" "),_("li",[_("p",[t._v("数据链路层 (data link layer)：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。")])]),t._v(" "),_("li",[_("p",[t._v("物理层 (physical Layer)：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。")])])]),t._v(" "),_("p",[t._v("每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：\n"),_("img",{attrs:{src:v(459),alt:""}})]),t._v(" "),_("p",[t._v("TCP/IP五层协议的通信方式也是对等通信：")]),t._v(" "),_("p",[_("img",{attrs:{src:v(460),alt:""}})]),t._v(" "),_("h2",{attrs:{id:"tcp与udp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp"}},[t._v("#")]),t._v(" TCP与UDP")]),t._v(" "),_("h3",{attrs:{id:"tcp-和-udp的概念及特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp的概念及特点"}},[t._v("#")]),t._v(" TCP 和 UDP的概念及特点")]),t._v(" "),_("p",[_("strong",[t._v("1. UDP")])]),t._v(" "),_("p",[t._v("UDP的全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。主要特点：")]),t._v(" "),_("ul",[_("li",[t._v("面向无连接：UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。\n"),_("ul",[_("li",[t._v("在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了")]),t._v(" "),_("li",[t._v("在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作")])])]),t._v(" "),_("li",[t._v("有单播，多播，广播的功能")]),t._v(" "),_("li",[t._v("面向报文：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文")]),t._v(" "),_("li",[t._v("不可靠性：不需要建立连接，想发就发，这样的情况肯定不可靠；网络条件不好的情况下可能会导致丢包；发送数据也不会关心对方是否已经正确接收到数据了")]),t._v(" "),_("li",[t._v("头部开销小，传输数据报文时是很高效的。头部包含了以下几个数据：\n"),_("ul",[_("li",[t._v("两个十六位的端口号，分别为源端口（可选字段）和目标端口")]),t._v(" "),_("li",[t._v("整个数据报文的长度")]),t._v(" "),_("li",[t._v("整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误")])])])]),t._v(" "),_("p",[_("strong",[t._v("2. TCP")]),t._v("\nTCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。它有以下几个特点：")]),t._v(" "),_("ul",[_("li",[t._v("面向连接：指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。")]),t._v(" "),_("li",[t._v("仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。")]),t._v(" "),_("li",[t._v("面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。")]),t._v(" "),_("li",[t._v("可靠传输：对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。")]),t._v(" "),_("li",[t._v("提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。")]),t._v(" "),_("li",[t._v("提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）")])]),t._v(" "),_("h3",{attrs:{id:"tcp和udp的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[t._v("#")]),t._v(" TCP和UDP的区别")]),t._v(" "),_("p",[_("img",{attrs:{src:v(461),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"udp协议为什么不可靠"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#udp协议为什么不可靠"}},[t._v("#")]),t._v(" UDP协议为什么不可靠")]),t._v(" "),_("p",[t._v("UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：")]),t._v(" "),_("ol",[_("li",[t._v("不保证消息交付：不确认，不重传，无超时")]),t._v(" "),_("li",[t._v("不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞")]),t._v(" "),_("li",[t._v("不跟踪连接状态：不必建立连接或重启状态机")]),t._v(" "),_("li",[t._v("不进行拥塞控制：不内置客户端或网络反馈机制")])]),t._v(" "),_("h3",{attrs:{id:"tcp的重传机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的重传机制"}},[t._v("#")]),t._v(" TCP的重传机制")]),t._v(" "),_("p",[t._v("由于TCP的下层网络（网络层）可能出现丢失、重复或失序的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是基于时间，二是基于确认信息。")]),t._v(" "),_("p",[t._v("TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。")]),t._v(" "),_("h3",{attrs:{id:"tcp的拥塞控制机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的拥塞控制机制"}},[t._v("#")]),t._v(" TCP的拥塞控制机制")]),t._v(" "),_("p",[t._v("TCP的拥塞控制机制主要是以下四种机制：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("慢启动（慢开始）:开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。（cwnd指的是拥塞窗口）\n为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)")]),t._v(" "),_("ul",[_("li",[t._v("当cnwd < ssthresh，使用慢开始算法")]),t._v(" "),_("li",[t._v("当cnwd = ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法")]),t._v(" "),_("li",[t._v("当cnwd > ssthresh，使用拥塞避免算法")])])]),t._v(" "),_("li",[_("p",[t._v("拥塞避免: 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一。无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:\n"),_("img",{attrs:{src:v(462),alt:""}})])]),t._v(" "),_("li",[_("p",[t._v("快速重传: 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。")])]),t._v(" "),_("li",[_("p",[t._v("快速恢复: 考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。\n"),_("img",{attrs:{src:v(463),alt:""}})])])]),t._v(" "),_("h3",{attrs:{id:"tcp的流量控制机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的流量控制机制"}},[t._v("#")]),t._v(" TCP的流量控制机制")]),t._v(" "),_("p",[t._v("流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。")]),t._v(" "),_("ul",[_("li",[t._v("当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。")]),t._v(" "),_("li",[t._v("当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）")]),t._v(" "),_("li",[t._v("如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。")]),t._v(" "),_("li",[t._v("如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。")])]),t._v(" "),_("h3",{attrs:{id:"tcp的可靠传输机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的可靠传输机制"}},[t._v("#")]),t._v(" TCP的可靠传输机制")]),t._v(" "),_("p",[t._v("TCP 的可靠传输机制是基于连续 ARQ 协议(即自动重传请求(Automatic Repeat-reQuest))和滑动窗口协议的。")]),t._v(" "),_("p",[t._v("TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。")]),t._v(" "),_("ol",[_("li",[t._v("当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。")]),t._v(" "),_("li",[t._v("如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。")]),t._v(" "),_("li",[t._v("如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。")]),t._v(" "),_("li",[t._v("当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。")])]),t._v(" "),_("p",[t._v("接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认 保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。")]),t._v(" "),_("p",[t._v("发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。")]),t._v(" "),_("h3",{attrs:{id:"tcp粘包是怎么回事-如何处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp粘包是怎么回事-如何处理"}},[t._v("#")]),t._v(" TCP粘包是怎么回事，如何处理?")]),t._v(" "),_("p",[t._v("默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能.")]),t._v(" "),_("p",[t._v("下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况:\nA. 先接收到 data1, 然后接收到 data2 .\nB. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部.\nC. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据.\nD. ⼀次性接收到了 data1 和 data2 的全部数据.")]),t._v(" "),_("p",[t._v("其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有:")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("多次发送之前间隔⼀个等待时间")]),t._v("：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理.")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("关闭 Nagle 算法")]),t._v("：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("进⾏封包/拆包")]),t._v("： 封包/拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前/后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。")])])]),t._v(" "),_("h3",{attrs:{id:"为什么udp不会粘包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么udp不会粘包"}},[t._v("#")]),t._v(" 为什么udp不会粘包")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据")])]),t._v(" "),_("li",[_("p",[t._v("UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。")])])]),t._v(" "),_("h2",{attrs:{id:"http协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议"}},[t._v("#")]),t._v(" HTTP协议")]),t._v(" "),_("h3",{attrs:{id:"get和post的请求的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#get和post的请求的区别"}},[t._v("#")]),t._v(" GET和POST的请求的区别")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("应用场景：")]),t._v(" GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。\n"),_("strong",[t._v("是否缓存：")]),t._v(" 因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。\n"),_("strong",[t._v("发送的报文格式：")]),t._v(" Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。\n"),_("strong",[t._v("安全性：")]),t._v(" Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。\n"),_("strong",[t._v("请求长度：")]),t._v(" 浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。\n"),_("strong",[t._v("参数类型：")]),t._v(" post 的参数传递支持更多的数据类型。")])]),t._v(" "),_("h3",{attrs:{id:"post和put请求的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#post和put请求的区别"}},[t._v("#")]),t._v(" POST和PUT请求的区别")]),t._v(" "),_("ul",[_("li",[t._v("PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）")]),t._v(" "),_("li",[t._v("POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）")])]),t._v(" "),_("h3",{attrs:{id:"常见的http请求头和响应头"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求头和响应头"}},[t._v("#")]),t._v(" 常见的HTTP请求头和响应头")]),t._v(" "),_("p",[_("strong",[t._v("HTTP Request Header 常见的请求头：")])]),t._v(" "),_("ul",[_("li",[t._v("Accept:浏览器能够处理的内容类型")]),t._v(" "),_("li",[t._v("Accept-Charset:浏览器能够显示的字符集")]),t._v(" "),_("li",[t._v("Accept-Encoding：浏览器能够处理的压缩编码")]),t._v(" "),_("li",[t._v("Accept-Language：浏览器当前设置的语言")]),t._v(" "),_("li",[t._v("Connection：浏览器与服务器之间连接的类型")]),t._v(" "),_("li",[t._v("Cookie：当前页面设置的任何Cookie")]),t._v(" "),_("li",[t._v("Host：发出请求的页面所在的域")]),t._v(" "),_("li",[t._v("Referer：发出请求的页面的URL")]),t._v(" "),_("li",[t._v("User-Agent：浏览器的用户代理字符串")])]),t._v(" "),_("p",[_("strong",[t._v("HTTP Responses Header 常见的响应头：")])]),t._v(" "),_("ul",[_("li",[t._v("Date：表示消息发送的时间，时间的描述格式由rfc822定义")]),t._v(" "),_("li",[t._v("server:服务器名称")]),t._v(" "),_("li",[t._v("Connection：浏览器与服务器之间连接的类型")]),t._v(" "),_("li",[t._v("Cache-Control：控制HTTP缓存")]),t._v(" "),_("li",[t._v("content-type:表示后面的文档属于什么MIME类型")])]),t._v(" "),_("p",[_("strong",[t._v("常见的 Content-Type 属性值有以下四种：")])]),t._v(" "),_("ul",[_("li",[t._v("application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。")]),t._v(" "),_("li",[t._v("multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。")]),t._v(" "),_("li",[t._v("application/json：服务器消息主体是序列化后的 JSON 字符串。")]),t._v(" "),_("li",[t._v("text/xml：该种方式主要用来提交 XML 格式的数据。")])]),t._v(" "),_("h3",{attrs:{id:"http状态码304是多好还是少好"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http状态码304是多好还是少好"}},[t._v("#")]),t._v(" HTTP状态码304是多好还是少好")]),t._v(" "),_("p",[t._v("搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。\n"),_("strong",[t._v("产生较多304状态码的原因：")])]),t._v(" "),_("ul",[_("li",[t._v("页面更新周期长或不更新")]),t._v(" "),_("li",[t._v("纯静态页面或强制生成静态html")])]),t._v(" "),_("p",[_("strong",[t._v("304状态码出现过多会造成以下问题：")])]),t._v(" "),_("ul",[_("li",[t._v("网站快照停止；")]),t._v(" "),_("li",[t._v("收录减少；")]),t._v(" "),_("li",[t._v("权重下降。")])]),t._v(" "),_("h3",{attrs:{id:"常见的http请求方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的http请求方法"}},[t._v("#")]),t._v(" 常见的HTTP请求方法")]),t._v(" "),_("ul",[_("li",[t._v("GET: 向服务器获取数据；")]),t._v(" "),_("li",[t._v("POST：将实体提交到指定的资源，通常会造成服务器资源的修改；")]),t._v(" "),_("li",[t._v("PUT：上传文件，更新数据；")]),t._v(" "),_("li",[t._v("DELETE：删除服务器上的对象；")]),t._v(" "),_("li",[t._v("HEAD：获取报文首部，与GET相比，不返回报文主体部分；")]),t._v(" "),_("li",[t._v("OPTIONS：询问支持的请求方法，用来跨域请求；")]),t._v(" "),_("li",[t._v("CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；")]),t._v(" "),_("li",[t._v("TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。")])]),t._v(" "),_("h3",{attrs:{id:"options请求方法及使用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#options请求方法及使用场景"}},[t._v("#")]),t._v(" OPTIONS请求方法及使用场景")]),t._v(" "),_("p",[t._v("OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。\n"),_("strong",[t._v("OPTIONS请求方法的主要用途有两个：")])]),t._v(" "),_("ul",[_("li",[t._v("获取服务器支持的所有HTTP请求方法；")]),t._v(" "),_("li",[t._v("用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。")])]),t._v(" "),_("h3",{attrs:{id:"http-1-0-和-http-1-1-之间有哪些区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-0-和-http-1-1-之间有哪些区别"}},[t._v("#")]),t._v(" HTTP 1.0 和 HTTP 1.1 之间有哪些区别")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("连接方面")]),t._v("，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。")]),t._v(" "),_("li",[_("strong",[t._v("资源请求方面")]),t._v(" ，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。")]),t._v(" "),_("li",[_("strong",[t._v("缓存方面")]),t._v("，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、Cache-Control 等更多可供选择的缓存头来控制缓存策略。")])]),t._v(" "),_("blockquote",[_("p",[t._v("no-store:永远都不要在客户端存储资源，永远都去原始服务器去获取资源。\nno-cache:可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。")])]),t._v(" "),_("ul",[_("li",[t._v("http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。")])]),t._v(" "),_("h3",{attrs:{id:"http-1-1-和-http-2-0-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-1-1-和-http-2-0-的区别"}},[t._v("#")]),t._v(" HTTP 1.1 和 HTTP 2.0 的区别")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("二进制协议：")]),t._v(' HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。')])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("多路复用：")]),t._v(' HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。')])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("数据流：")]),t._v(" HTTP/2 使用了数据流的概念，因为 HTTP/2 的**数据包(帧)**是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("头信息压缩：")]),t._v(" HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使"),_("strong",[t._v("用 gzip 或 compress 压缩后再发送")]),t._v("；另一方面，客户端和服务器"),_("strong",[t._v("同时维护一张头信息表")]),t._v("，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("服务器推送：")]),t._v(" HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。")])])]),t._v(" "),_("p",[_("strong",[t._v("【1】队头堵塞：")])]),t._v(" "),_("blockquote",[_("p",[t._v("队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。")])]),t._v(" "),_("h3",{attrs:{id:"当在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#当在浏览器中输入-google-com-并且按下回车之后发生了什么"}},[t._v("#")]),t._v(" 当在浏览器中输入 Google.com 并且按下回车之后发生了什么")]),t._v(" "),_("p",[t._v("（1）"),_("strong",[t._v("解析URL：")]),t._v(" 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。\n（2）"),_("strong",[t._v("缓存判断：")]),t._v(" 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。\n（3）"),_("strong",[t._v("DNS解析：")]),t._v(" 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。"),_("strong",[t._v("用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。")]),t._v("\n（4）"),_("strong",[t._v("获取MAC地址：")]),t._v(" (ARP协议)当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。\n（5）"),_("strong",[t._v("TCP三次握手：")]),t._v(" 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。\n（6）HTTPS握手： 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。\n（7）返回数据： 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。\n（8）页面渲染： 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。\n（9）TCP四次挥手： 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。")]),t._v(" "),_("h3",{attrs:{id:"页面有多张图片-http是怎样的加载表现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面有多张图片-http是怎样的加载表现"}},[t._v("#")]),t._v(" 页面有多张图片，HTTP是怎样的加载表现？")]),t._v(" "),_("ul",[_("li",[t._v("在HTTP 1下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用多域名部署解决。这样可以提高同时请求的数目，加快页面图片的获取速度。")]),t._v(" "),_("li",[t._v("在HTTP 2下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。")])]),t._v(" "),_("h3",{attrs:{id:"http2的头部压缩算法是怎样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http2的头部压缩算法是怎样的"}},[t._v("#")]),t._v(" HTTP2的头部压缩算法是怎样的")]),t._v(" "),_("p",[t._v("在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。具体来说:")]),t._v(" "),_("ul",[_("li",[t._v("在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；")]),t._v(" "),_("li",[t._v("首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；")]),t._v(" "),_("li",[t._v("每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。")])]),t._v(" "),_("p",[t._v("例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。\n"),_("img",{attrs:{src:v(464),alt:""}})]),t._v(" "),_("h3",{attrs:{id:"说一下http-3-0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说一下http-3-0"}},[t._v("#")]),t._v(" 说一下HTTP 3.0")]),t._v(" "),_("p",[t._v("HTTP/3基于UDP协议实现了类似于TCP的"),_("strong",[t._v("多路复用")]),t._v("、"),_("strong",[t._v("数据流")]),t._v("、"),_("strong",[t._v("传输可靠性")]),t._v("等功能，这套功能被称为QUIC协议。")]),t._v(" "),_("ul",[_("li",[t._v("流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。")]),t._v(" "),_("li",[t._v("集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。")]),t._v(" "),_("li",[t._v("多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。")]),t._v(" "),_("li",[t._v("快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。")])]),t._v(" "),_("h3",{attrs:{id:"http协议的性能怎么样"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http协议的性能怎么样"}},[t._v("#")]),t._v(" HTTP协议的性能怎么样")]),t._v(" "),_("p",[t._v("HTTP 协议是基于 TCP/IP，并且使用了请求-应答的通信模式，所以性能的关键就在这三点里。")]),t._v(" "),_("p",[_("strong",[t._v("1.长连接")])]),t._v(" "),_("ul",[_("li",[t._v("在HTTP/1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。")]),t._v(" "),_("li",[t._v("在HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。\n"),_("img",{attrs:{src:v(465),alt:""}})])]),t._v(" "),_("p",[_("strong",[t._v("2.管道网络传输")]),t._v("\nHTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。")]),t._v(" "),_("p",[t._v("管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。")]),t._v(" "),_("p",[_("strong",[t._v("3.队头堵塞")])]),t._v(" "),_("p",[t._v("HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。")]),t._v(" "),_("p",[_("strong",[t._v("队头阻塞的解决方案：")]),t._v(" （1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。 （2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。")]),t._v(" "),_("h3",{attrs:{id:"与缓存相关的http请求头有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与缓存相关的http请求头有哪些"}},[t._v("#")]),t._v(" 与缓存相关的HTTP请求头有哪些")]),t._v(" "),_("p",[t._v("强缓存：")]),t._v(" "),_("ul",[_("li",[t._v("Expires")]),t._v(" "),_("li",[t._v("Cache-Control")])]),t._v(" "),_("p",[t._v("协商缓存：")]),t._v(" "),_("ul",[_("li",[t._v("Etag、If-None-Match")]),t._v(" "),_("li",[t._v("Last-Modified、If-Modified-Since")])]),t._v(" "),_("h2",{attrs:{id:"https协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https协议"}},[t._v("#")]),t._v(" HTTPS协议")]),t._v(" "),_("h3",{attrs:{id:"数字证书是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数字证书是什么"}},[t._v("#")]),t._v(" 数字证书是什么")]),t._v(" "),_("ul",[_("li",[t._v("首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要")]),t._v(" "),_("li",[t._v("然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。")]),t._v(" "),_("li",[t._v("当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。")])]),t._v(" "),_("h3",{attrs:{id:"https通信-握手-过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https通信-握手-过程"}},[t._v("#")]),t._v(" HTTPS通信（握手）过程")]),t._v(" "),_("ol",[_("li",[t._v("客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。")]),t._v(" "),_("li",[t._v("服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。")]),t._v(" "),_("li",[t._v("客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。")]),t._v(" "),_("li",[t._v("服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。")]),t._v(" "),_("li",[t._v("客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。")])]),t._v(" "),_("h3",{attrs:{id:"https的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https的特点"}},[t._v("#")]),t._v(" HTTPS的特点")]),t._v(" "),_("p",[_("strong",[t._v("HTTPS的优点如下：")])]),t._v(" "),_("ul",[_("li",[t._v("使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；")]),t._v(" "),_("li",[t._v("使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；")]),t._v(" "),_("li",[t._v("HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；")])]),t._v(" "),_("p",[_("strong",[t._v("HTTPS的缺点如下：")])]),t._v(" "),_("ul",[_("li",[t._v("HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；")]),t._v(" "),_("li",[t._v("HTTPS协议握手阶段比较费时，增加页面的加载时间；")]),t._v(" "),_("li",[t._v("SSL证书是收费的，功能越强大的证书费用越高；")]),t._v(" "),_("li",[t._v("HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；")]),t._v(" "),_("li",[t._v("SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。")])]),t._v(" "),_("h3",{attrs:{id:"https是如何保证安全的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https是如何保证安全的"}},[t._v("#")]),t._v(" HTTPS是如何保证安全的")]),t._v(" "),_("p",[t._v("⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。")]),t._v(" "),_("p",[_("strong",[t._v("解决⽅案：")])]),t._v(" "),_("p",[t._v("结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。")]),t._v(" "),_("p",[t._v("此时⼜带来⼀个问题，中间⼈问题：如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。")]),t._v(" "),_("p",[t._v("所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。")]),t._v(" "),_("p",[t._v("但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。")]),t._v(" "),_("p",[t._v("数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。")]),t._v(" "),_("h3",{attrs:{id:"https-中间人攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-中间人攻击"}},[t._v("#")]),t._v(" HTTPS 中间人攻击")]),t._v(" "),_("p",[t._v("针对 HTTPS 攻击主要有 SSL 劫持攻击和 SSL 剥离攻击两种。")]),t._v(" "),_("p",[_("strong",[t._v("SSL 劫持攻击")]),t._v("是指攻击者劫持了客户端和服务器之间的连接，将服务器的合法证书替换为伪造的证书，从而获取客户端和服务器之间传递的信息。这种方式一般容易被用户发现，浏览器会明确的提示证书错误，但某些用户安全意识不强，可能会点击继续浏览，从而达到攻击目的。")]),t._v(" "),_("p",[_("strong",[t._v("SSL 剥离攻击")]),t._v("是指攻击者劫持了客户端和服务器之间的连接，攻击者保持自己和服务器之间的 HTTPS 连接，但发送给客户端普通的 HTTP 连接，由于 HTTP 连接是明文传输的，即可获取客户端传输的所有明文数据。")]),t._v(" "),_("h2",{attrs:{id:"dns协议介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns协议介绍"}},[t._v("#")]),t._v(" DNS协议介绍")]),t._v(" "),_("h3",{attrs:{id:"dns-协议是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns-协议是什么"}},[t._v("#")]),t._v(" DNS 协议是什么")]),t._v(" "),_("p",[_("strong",[t._v("概念：")]),t._v(" DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。")]),t._v(" "),_("p",[_("strong",[t._v("作用：")]),t._v(" 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。")]),t._v(" "),_("h3",{attrs:{id:"dns同时使用tcp和udp协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns同时使用tcp和udp协议"}},[t._v("#")]),t._v(" DNS同时使用TCP和UDP协议？")]),t._v(" "),_("p",[t._v("DNS占用53号端口，同时使用TCP和UDP协议。")]),t._v(" "),_("p",[_("strong",[t._v("（1）在区域传输的时候使用TCP协议")])]),t._v(" "),_("p",[t._v("辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。\nTCP是一种可靠连接，保证了数据的准确性。")]),t._v(" "),_("p",[_("strong",[t._v("（2）在域名解析的时候使用UDP协议")])]),t._v(" "),_("p",[t._v("客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。")]),t._v(" "),_("h3",{attrs:{id:"dns完整的查询过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns完整的查询过程"}},[t._v("#")]),t._v(" DNS完整的查询过程")]),t._v(" "),_("ul",[_("li",[t._v("首先会在"),_("strong",[t._v("浏览器的缓存")]),t._v("中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步")]),t._v(" "),_("li",[t._v("将请求发送给"),_("strong",[t._v("本地DNS服务器")]),t._v("，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步")]),t._v(" "),_("li",[t._v("本地DNS服务器向"),_("strong",[t._v("根域名服务器")]),t._v("发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址")]),t._v(" "),_("li",[t._v("本地DNS服务器向"),_("strong",[t._v("顶级域名服务器")]),t._v("发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址")]),t._v(" "),_("li",[t._v("本地DNS服务器向"),_("strong",[t._v("权威域名服务器")]),t._v("发送请求，域名服务器返回对应的结果")]),t._v(" "),_("li",[t._v("本地DNS服务器将返回结果保存在缓存中，便于下次使用")]),t._v(" "),_("li",[t._v("本地DNS服务器将返回结果返回给浏览器")])]),t._v(" "),_("p",[t._v("比如要查询 www.baidu.com 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。")]),t._v(" "),_("h3",{attrs:{id:"迭代查询与递归查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迭代查询与递归查询"}},[t._v("#")]),t._v(" 迭代查询与递归查询")]),t._v(" "),_("ul",[_("li",[t._v("递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。")]),t._v(" "),_("li",[t._v("迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。")])]),t._v(" "),_("p",[t._v("一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。")]),t._v(" "),_("h3",{attrs:{id:"dns-记录和报文"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns-记录和报文"}},[t._v("#")]),t._v(" DNS 记录和报文")]),t._v(" "),_("p",[t._v("DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("（Name，Value，Type，TTL）\n")])])]),_("p",[t._v("其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。")]),t._v(" "),_("p",[t._v("常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：")]),t._v(" "),_("ul",[_("li",[t._v("如果 Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。")]),t._v(" "),_("li",[t._v("如果 Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。")]),t._v(" "),_("li",[t._v("如果 Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。")]),t._v(" "),_("li",[t._v("如果 Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。")])]),t._v(" "),_("h3",{attrs:{id:"dns-劫持"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dns-劫持"}},[t._v("#")]),t._v(" DNS 劫持")]),t._v(" "),_("p",[t._v("DNS 劫持是指攻击者劫持了 DNS 服务器，获得了修改 DNS 解析记录的权限，从而导致客户端请求的域名被解析到了错误的 IP 地址，攻击者通过这种方式窃取用户资料或破坏原有正常服务。")]),t._v(" "),_("h2",{attrs:{id:"单点登录-sso"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单点登录-sso"}},[t._v("#")]),t._v(" 单点登录(SSO)")]),t._v(" "),_("p",[_("a",{attrs:{href:"https://juejin.cn/post/7044328327762411534",target:"_blank",rel:"noopener noreferrer"}},[t._v("单点登录原理"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=s.exports}}]);