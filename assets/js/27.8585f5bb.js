(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{494:function(t,e,n){"use strict";n.r(e);var a=n(2),r=Object(a.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"typescript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript"}},[t._v("#")]),t._v(" TypeScript")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/JasonkayZK/typescript-learn/tree/1-type",target:"_blank",rel:"noopener noreferrer"}},[t._v("尚硅谷TS学习笔记"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://gitee.com/hongjilin/hongs-study-notes/tree/master/%E7%BC%96%E7%A8%8B_%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TypeScrip%E7%AC%94%E8%AE%B0",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript笔记"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6872111128135073806",target:"_blank",rel:"noopener noreferrer"}},[e("strong",[t._v("一份不可多得的 TS 学习指南")]),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"ts概念区分"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ts概念区分"}},[t._v("#")]),t._v(" "),e("a",{attrs:{href:"http://www.alloyteam.com/2019/07/13796/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TS概念区分"),e("OutboundLink")],1)]),t._v(" "),e("h3",{attrs:{id:"interface-type"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#interface-type"}},[t._v("#")]),t._v(" interface & type")]),t._v(" "),e("p",[t._v("接口和类型别名都可以用来描述对象的形状或函数签名")]),t._v(" "),e("ul",[e("li",[t._v("与类型别名不同，接口可以定义多次，会被自动合并为单个接口。而 type 只能使用 & 类进行连接。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("interface A {\n    a: number;\n}\n\ninterface A {\n    b: number;\n}\n\nconst a: A = {\n    a: 3,\n    b: 4\n}\n")])])]),e("ul",[e("li",[t._v("type 可以声明基本类型别名，联合类型，元组等类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 基本类型别名\ntype Name = string\n\n// 联合类型\ninterface Dog {\n    wong();\n}\ninterface Cat {\n    miao();\n}\n\ntype Pet = Dog | Cat\n\n// 具体定义数组每个位置的类型\ntype PetList = [Dog, Pet]\n")])])]),e("ul",[e("li",[t._v("type 语句中还可以使用 typeof 获取实例的 类型进行赋值")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createElement('div');\ntype B = typeof div\n\n// 字符串字面量类型用来约束取值只能是某几个字符串中的一个\ntype EventNames = 'click' | 'scroll' | 'mousemove';\n")])])]),e("ul",[e("li",[t._v("类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type PartialPoint = { x: number; } | { y: number; };\n\n// A class can only implement an object type or \n// intersection of object types with statically known members.\nclass SomePartialPoint implements PartialPoint { // Error\n  x = 1;\n  y = 2;\n}\n")])])]),e("h3",{attrs:{id:"和-操作符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和-操作符"}},[t._v("#")]),t._v(" &和 | 操作符")]),t._v(" "),e("p",[t._v("虽然在写法上，这两个操作符与位运算逻辑操作符相同。但在语义上，它们与位运算刚好相反。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("interface IA {\n    a: string\n    b: number\n}\n \ntype TB = {\n    b: number\n    c: number[]\n}\n \ntype TC = IA | TB;    // TC类型的变量的键只需包含ab或bc即可，当然也可以abc都有\ntype TD = IA & TB;    // TD类型的变量的键必需包含abc\n")])])]),e("h3",{attrs:{id:"extends-关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#extends-关键字"}},[t._v("#")]),t._v(" extends 关键字")]),t._v(" "),e("p",[t._v("extends 本意为 “拓展”，也有人称其为 “继承”。在 TypeScript 中，extends 既可当作一个动词来扩展已有类型；也可当作一个形容词来对类型进行条件限定（例如用在泛型中）。在扩展已有类型时，不可以进行类型冲突的覆盖操作。例如，基类型中键 a 为 string，在扩展出的类型中无法将其改为 number。")]),t._v(" "),e("h3",{attrs:{id:"泛型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),e("p",[t._v("类型实际上可以进行一定的运算，要想写出的类型适用范围更广，不妨让它像函数一样可以接受参数。TS 的泛型便是起到这样的作用，你可以把它当作类型的参数。它和函数参数一样，可以有默认值。除此之外，还可以用 extends 对参数本身需要满足的条件进行限制。")]),t._v(" "),e("blockquote",[e("p",[t._v("设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：\n1、类的实例成员\n2、类的方法\n3、函数参数\n4、函数返回值\n以便于接口、函数的通用")])]),t._v(" "),e("p",[t._v("在定义一个函数、type、interface、class 时，在名称后面加上<> 表示即接受类型参数。而在实际调用时，不一定需要手动传入类型参数，TS 往往能自行推断出来。在 TS 推断不准时，再手动传入参数来纠正。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 定义\nclass React.Component<P = {}, S = {}, SS = any> { ... }\ninterface IShowConfig<P extends IShowProps> { ... }\n// 调用\nclass Modal extends React.Component<IModalProps, IModalState> { ... }\n")])])]),e("h3",{attrs:{id:"never-void"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#never-void"}},[t._v("#")]),t._v(" never & void")]),t._v(" "),e("ol",[e("li",[t._v("never 类型是 TypeScript 中的底层类型。它自然被分配的一些例子：")])]),t._v(" "),e("ul",[e("li",[t._v("一个从来不会有返回值的函数（如：如果函数内含有 "),e("code",[t._v("while(true) {}")]),t._v("）；")]),t._v(" "),e("li",[t._v("一个总是会抛出错误的函数（如："),e("code",[t._v("function foo() { throw new Error('Not Implemented') }")]),t._v("，foo 的返回类型是 never）；")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[t._v("当一个函数返回空值时，它的返回值为 void 类型，但是，当一个函数永不返回时（或者总是抛出错误），它的返回值为 never 类型。void 类型可以被赋值（在 strictNullChecking 为 false 时），但是除了 never 本身以外，其他任何类型不能赋值给 never。")])]),t._v(" "),e("blockquote",[e("p",[t._v("使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。")])]),t._v(" "),e("h3",{attrs:{id:"any-unkonwn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#any-unkonwn"}},[t._v("#")]),t._v(" any & unkonwn")]),t._v(" "),e("ol",[e("li",[t._v("任何值都可以赋值给 unknown 类型，但是 unknown 类型只能赋值给 unknown 和 any。")]),t._v(" "),e("li",[t._v("将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let value: unknown;\n\nvalue.foo.bar; // Error\nvalue.trim(); // Error\nvalue(); // Error\nnew value(); // Error\nvalue[0][1]; // Error\n\n")])])]),e("h3",{attrs:{id:"as-const"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#as-const"}},[t._v("#")]),t._v(" as const")]),t._v(" "),e("blockquote",[e("p",[t._v("as 断言 const 常量 断言为常量，一般const声明的常量对于对象数组这种只是不能更改其地址，as const以后值也不能变了")])]),t._v(" "),e("p",[t._v("当 as const 修饰符用在变量声明或表达式的类型上时，它会强制 TypeScript 将变量或表达式的类型视为不可变的（immutable）。这意味着，如果你尝试对变量或表达式进行修改，TypeScript 会报错。\n例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const foo = ['a', 'b'] as const;\nfoo.push('c');  // TypeScript 会报错，因为 foo 类型被声明为不可变的\n\nconst bar = { x: 1, y: 2 } as const;\nbar.x = 3;  // TypeScript 会报错，因为 bar 类型被声明为不可变的\n")])])]),e("h2",{attrs:{id:"typescript-断言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#typescript-断言"}},[t._v("#")]),t._v(" TypeScript 断言")]),t._v(" "),e("h3",{attrs:{id:"类型断言的用途"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型断言的用途"}},[t._v("#")]),t._v(" 类型断言的用途")]),t._v(" "),e("ol",[e("li",[t._v("将一个联合类型断言为其中一个类型")]),t._v(" "),e("li",[t._v("将一个父类断言为更加具体的子类")]),t._v(" "),e("li",[t._v("将任何一个类型断言为 any\n我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。此时我们可以使用 as any 临时将 window 断言为 any 类型：")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("(window as any).foo = 1;\n")])])]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("将 any 断言为一个具体的类型")])]),t._v(" "),e("blockquote",[e("p",[t._v("联合类型可以被断言为其中一个类型\n父类可以被断言为子类\n任何类型都可以被断言为 any\nany 可以被断言为任何类型\n要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可")])]),t._v(" "),e("h3",{attrs:{id:"非空断言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非空断言"}},[t._v("#")]),t._v(" 非空断言")]),t._v(" "),e("p",[t._v("在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。"),e("strong",[t._v("具体而言，x! 将从 x 值域中排除 null 和 undefined 。")])]),t._v(" "),e("ol",[e("li",[t._v("忽略 undefined 和 null 类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function myFunc(maybeString: string | undefined | null) {\n  // Type 'string | null | undefined' is not assignable to type 'string'.\n  // Type 'undefined' is not assignable to type 'string'. \n  const onlyString: string = maybeString; // Error\n  const ignoreUndefinedAndNull: string = maybeString!; // Ok\n}\n")])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("调用函数时忽略 undefined 类型")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("type NumGenerator = () => number;\n\nfunction myFunc(numGenerator: NumGenerator | undefined) {\n  // Object is possibly 'undefined'.(2532)\n  // Cannot invoke an object which is possibly 'undefined'.(2722)\n  const num1 = numGenerator(); // Error\n  const num2 = numGenerator!(); //OK\n}\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("确定赋值断言")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let x: number;\ninitialize();\n// Variable 'x' is used before being assigned.(2454)\nconsole.log(2 * x); // Error\n\nfunction initialize() {\n  x = 10;\n}\n\n")])])]),e("p",[t._v("该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let x!: number;\n")])])]),e("h2",{attrs:{id:"vue2配置使用typescript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2配置使用typescript"}},[t._v("#")]),t._v(" vue2配置使用typescript")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://blog.csdn.net/u010059669/article/details/109292214",target:"_blank",rel:"noopener noreferrer"}},[t._v("vue2配置使用typescript"),e("OutboundLink")],1),t._v(" "),e("a",{attrs:{href:"https://juejin.cn/post/6844903641829081095",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript + 大型项目实战"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);